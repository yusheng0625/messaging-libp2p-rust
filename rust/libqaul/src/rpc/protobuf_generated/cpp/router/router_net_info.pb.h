// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: router/router_net_info.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_router_2frouter_5fnet_5finfo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_router_2frouter_5fnet_5finfo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_router_2frouter_5fnet_5finfo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_router_2frouter_5fnet_5finfo_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_router_2frouter_5fnet_5finfo_2eproto;
namespace qaul {
namespace net {
namespace router_net_info {
class FeedIdsTable;
struct FeedIdsTableDefaultTypeInternal;
extern FeedIdsTableDefaultTypeInternal _FeedIdsTable_default_instance_;
class FeedMessage;
struct FeedMessageDefaultTypeInternal;
extern FeedMessageDefaultTypeInternal _FeedMessage_default_instance_;
class FeedRequestMessage;
struct FeedRequestMessageDefaultTypeInternal;
extern FeedRequestMessageDefaultTypeInternal _FeedRequestMessage_default_instance_;
class FeedResponseMessage;
struct FeedResponseMessageDefaultTypeInternal;
extern FeedResponseMessageDefaultTypeInternal _FeedResponseMessage_default_instance_;
class FeedResponseTable;
struct FeedResponseTableDefaultTypeInternal;
extern FeedResponseTableDefaultTypeInternal _FeedResponseTable_default_instance_;
class RouterInfoContainer;
struct RouterInfoContainerDefaultTypeInternal;
extern RouterInfoContainerDefaultTypeInternal _RouterInfoContainer_default_instance_;
class RouterInfoContent;
struct RouterInfoContentDefaultTypeInternal;
extern RouterInfoContentDefaultTypeInternal _RouterInfoContent_default_instance_;
class RouterInfoMessage;
struct RouterInfoMessageDefaultTypeInternal;
extern RouterInfoMessageDefaultTypeInternal _RouterInfoMessage_default_instance_;
class RoutingInfoEntry;
struct RoutingInfoEntryDefaultTypeInternal;
extern RoutingInfoEntryDefaultTypeInternal _RoutingInfoEntry_default_instance_;
class RoutingInfoTable;
struct RoutingInfoTableDefaultTypeInternal;
extern RoutingInfoTableDefaultTypeInternal _RoutingInfoTable_default_instance_;
class UserIdTable;
struct UserIdTableDefaultTypeInternal;
extern UserIdTableDefaultTypeInternal _UserIdTable_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
class UserInfoTable;
struct UserInfoTableDefaultTypeInternal;
extern UserInfoTableDefaultTypeInternal _UserInfoTable_default_instance_;
}  // namespace router_net_info
}  // namespace net
}  // namespace qaul
PROTOBUF_NAMESPACE_OPEN
template<> ::qaul::net::router_net_info::FeedIdsTable* Arena::CreateMaybeMessage<::qaul::net::router_net_info::FeedIdsTable>(Arena*);
template<> ::qaul::net::router_net_info::FeedMessage* Arena::CreateMaybeMessage<::qaul::net::router_net_info::FeedMessage>(Arena*);
template<> ::qaul::net::router_net_info::FeedRequestMessage* Arena::CreateMaybeMessage<::qaul::net::router_net_info::FeedRequestMessage>(Arena*);
template<> ::qaul::net::router_net_info::FeedResponseMessage* Arena::CreateMaybeMessage<::qaul::net::router_net_info::FeedResponseMessage>(Arena*);
template<> ::qaul::net::router_net_info::FeedResponseTable* Arena::CreateMaybeMessage<::qaul::net::router_net_info::FeedResponseTable>(Arena*);
template<> ::qaul::net::router_net_info::RouterInfoContainer* Arena::CreateMaybeMessage<::qaul::net::router_net_info::RouterInfoContainer>(Arena*);
template<> ::qaul::net::router_net_info::RouterInfoContent* Arena::CreateMaybeMessage<::qaul::net::router_net_info::RouterInfoContent>(Arena*);
template<> ::qaul::net::router_net_info::RouterInfoMessage* Arena::CreateMaybeMessage<::qaul::net::router_net_info::RouterInfoMessage>(Arena*);
template<> ::qaul::net::router_net_info::RoutingInfoEntry* Arena::CreateMaybeMessage<::qaul::net::router_net_info::RoutingInfoEntry>(Arena*);
template<> ::qaul::net::router_net_info::RoutingInfoTable* Arena::CreateMaybeMessage<::qaul::net::router_net_info::RoutingInfoTable>(Arena*);
template<> ::qaul::net::router_net_info::UserIdTable* Arena::CreateMaybeMessage<::qaul::net::router_net_info::UserIdTable>(Arena*);
template<> ::qaul::net::router_net_info::UserInfo* Arena::CreateMaybeMessage<::qaul::net::router_net_info::UserInfo>(Arena*);
template<> ::qaul::net::router_net_info::UserInfoTable* Arena::CreateMaybeMessage<::qaul::net::router_net_info::UserInfoTable>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace qaul {
namespace net {
namespace router_net_info {

enum RouterInfoModule : int {
  ROUTER_INFO = 0,
  FEED_REQUEST = 1,
  FEED_RESPONSE = 2,
  USER_REQUEST = 3,
  USER_RESPONSE = 4,
  RouterInfoModule_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RouterInfoModule_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RouterInfoModule_IsValid(int value);
constexpr RouterInfoModule RouterInfoModule_MIN = ROUTER_INFO;
constexpr RouterInfoModule RouterInfoModule_MAX = USER_RESPONSE;
constexpr int RouterInfoModule_ARRAYSIZE = RouterInfoModule_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RouterInfoModule_descriptor();
template<typename T>
inline const std::string& RouterInfoModule_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RouterInfoModule>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RouterInfoModule_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RouterInfoModule_descriptor(), enum_t_value);
}
inline bool RouterInfoModule_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RouterInfoModule* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RouterInfoModule>(
    RouterInfoModule_descriptor(), name, value);
}
// ===================================================================

class RouterInfoContainer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.RouterInfoContainer) */ {
 public:
  inline RouterInfoContainer() : RouterInfoContainer(nullptr) {}
  ~RouterInfoContainer() override;
  explicit PROTOBUF_CONSTEXPR RouterInfoContainer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouterInfoContainer(const RouterInfoContainer& from);
  RouterInfoContainer(RouterInfoContainer&& from) noexcept
    : RouterInfoContainer() {
    *this = ::std::move(from);
  }

  inline RouterInfoContainer& operator=(const RouterInfoContainer& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterInfoContainer& operator=(RouterInfoContainer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterInfoContainer& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterInfoContainer* internal_default_instance() {
    return reinterpret_cast<const RouterInfoContainer*>(
               &_RouterInfoContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RouterInfoContainer& a, RouterInfoContainer& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterInfoContainer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterInfoContainer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterInfoContainer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterInfoContainer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouterInfoContainer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RouterInfoContainer& from) {
    RouterInfoContainer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterInfoContainer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.RouterInfoContainer";
  }
  protected:
  explicit RouterInfoContainer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // bytes signature = 1;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // bytes message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.RouterInfoContainer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class RouterInfoContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.RouterInfoContent) */ {
 public:
  inline RouterInfoContent() : RouterInfoContent(nullptr) {}
  ~RouterInfoContent() override;
  explicit PROTOBUF_CONSTEXPR RouterInfoContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouterInfoContent(const RouterInfoContent& from);
  RouterInfoContent(RouterInfoContent&& from) noexcept
    : RouterInfoContent() {
    *this = ::std::move(from);
  }

  inline RouterInfoContent& operator=(const RouterInfoContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterInfoContent& operator=(RouterInfoContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterInfoContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterInfoContent* internal_default_instance() {
    return reinterpret_cast<const RouterInfoContent*>(
               &_RouterInfoContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RouterInfoContent& a, RouterInfoContent& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterInfoContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterInfoContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterInfoContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterInfoContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouterInfoContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RouterInfoContent& from) {
    RouterInfoContent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterInfoContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.RouterInfoContent";
  }
  protected:
  explicit RouterInfoContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kContentFieldNumber = 3,
    kTimeFieldNumber = 4,
    kRouterInfoModuleFieldNumber = 2,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // uint64 time = 4;
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // .qaul.net.router_net_info.RouterInfoModule routerInfoModule = 2;
  void clear_routerinfomodule();
  ::qaul::net::router_net_info::RouterInfoModule routerinfomodule() const;
  void set_routerinfomodule(::qaul::net::router_net_info::RouterInfoModule value);
  private:
  ::qaul::net::router_net_info::RouterInfoModule _internal_routerinfomodule() const;
  void _internal_set_routerinfomodule(::qaul::net::router_net_info::RouterInfoModule value);
  public:

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.RouterInfoContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    uint64_t time_;
    int routerinfomodule_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class RouterInfoMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.RouterInfoMessage) */ {
 public:
  inline RouterInfoMessage() : RouterInfoMessage(nullptr) {}
  ~RouterInfoMessage() override;
  explicit PROTOBUF_CONSTEXPR RouterInfoMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouterInfoMessage(const RouterInfoMessage& from);
  RouterInfoMessage(RouterInfoMessage&& from) noexcept
    : RouterInfoMessage() {
    *this = ::std::move(from);
  }

  inline RouterInfoMessage& operator=(const RouterInfoMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterInfoMessage& operator=(RouterInfoMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterInfoMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterInfoMessage* internal_default_instance() {
    return reinterpret_cast<const RouterInfoMessage*>(
               &_RouterInfoMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RouterInfoMessage& a, RouterInfoMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterInfoMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterInfoMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterInfoMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterInfoMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouterInfoMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RouterInfoMessage& from) {
    RouterInfoMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterInfoMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.RouterInfoMessage";
  }
  protected:
  explicit RouterInfoMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 1,
    kRoutesFieldNumber = 2,
    kFeedsFieldNumber = 4,
    kTimestampFieldNumber = 5,
  };
  // bytes node = 1;
  void clear_node();
  const std::string& node() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node();
  PROTOBUF_NODISCARD std::string* release_node();
  void set_allocated_node(std::string* node);
  private:
  const std::string& _internal_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node(const std::string& value);
  std::string* _internal_mutable_node();
  public:

  // .qaul.net.router_net_info.RoutingInfoTable routes = 2;
  bool has_routes() const;
  private:
  bool _internal_has_routes() const;
  public:
  void clear_routes();
  const ::qaul::net::router_net_info::RoutingInfoTable& routes() const;
  PROTOBUF_NODISCARD ::qaul::net::router_net_info::RoutingInfoTable* release_routes();
  ::qaul::net::router_net_info::RoutingInfoTable* mutable_routes();
  void set_allocated_routes(::qaul::net::router_net_info::RoutingInfoTable* routes);
  private:
  const ::qaul::net::router_net_info::RoutingInfoTable& _internal_routes() const;
  ::qaul::net::router_net_info::RoutingInfoTable* _internal_mutable_routes();
  public:
  void unsafe_arena_set_allocated_routes(
      ::qaul::net::router_net_info::RoutingInfoTable* routes);
  ::qaul::net::router_net_info::RoutingInfoTable* unsafe_arena_release_routes();

  // .qaul.net.router_net_info.FeedIdsTable feeds = 4;
  bool has_feeds() const;
  private:
  bool _internal_has_feeds() const;
  public:
  void clear_feeds();
  const ::qaul::net::router_net_info::FeedIdsTable& feeds() const;
  PROTOBUF_NODISCARD ::qaul::net::router_net_info::FeedIdsTable* release_feeds();
  ::qaul::net::router_net_info::FeedIdsTable* mutable_feeds();
  void set_allocated_feeds(::qaul::net::router_net_info::FeedIdsTable* feeds);
  private:
  const ::qaul::net::router_net_info::FeedIdsTable& _internal_feeds() const;
  ::qaul::net::router_net_info::FeedIdsTable* _internal_mutable_feeds();
  public:
  void unsafe_arena_set_allocated_feeds(
      ::qaul::net::router_net_info::FeedIdsTable* feeds);
  ::qaul::net::router_net_info::FeedIdsTable* unsafe_arena_release_feeds();

  // uint64 timestamp = 5;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.RouterInfoMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_;
    ::qaul::net::router_net_info::RoutingInfoTable* routes_;
    ::qaul::net::router_net_info::FeedIdsTable* feeds_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class RoutingInfoTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.RoutingInfoTable) */ {
 public:
  inline RoutingInfoTable() : RoutingInfoTable(nullptr) {}
  ~RoutingInfoTable() override;
  explicit PROTOBUF_CONSTEXPR RoutingInfoTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingInfoTable(const RoutingInfoTable& from);
  RoutingInfoTable(RoutingInfoTable&& from) noexcept
    : RoutingInfoTable() {
    *this = ::std::move(from);
  }

  inline RoutingInfoTable& operator=(const RoutingInfoTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingInfoTable& operator=(RoutingInfoTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingInfoTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingInfoTable* internal_default_instance() {
    return reinterpret_cast<const RoutingInfoTable*>(
               &_RoutingInfoTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RoutingInfoTable& a, RoutingInfoTable& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingInfoTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingInfoTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutingInfoTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoutingInfoTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingInfoTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoutingInfoTable& from) {
    RoutingInfoTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingInfoTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.RoutingInfoTable";
  }
  protected:
  explicit RoutingInfoTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .qaul.net.router_net_info.RoutingInfoEntry entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::qaul::net::router_net_info::RoutingInfoEntry* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::RoutingInfoEntry >*
      mutable_entry();
  private:
  const ::qaul::net::router_net_info::RoutingInfoEntry& _internal_entry(int index) const;
  ::qaul::net::router_net_info::RoutingInfoEntry* _internal_add_entry();
  public:
  const ::qaul::net::router_net_info::RoutingInfoEntry& entry(int index) const;
  ::qaul::net::router_net_info::RoutingInfoEntry* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::RoutingInfoEntry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.RoutingInfoTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::RoutingInfoEntry > entry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class RoutingInfoEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.RoutingInfoEntry) */ {
 public:
  inline RoutingInfoEntry() : RoutingInfoEntry(nullptr) {}
  ~RoutingInfoEntry() override;
  explicit PROTOBUF_CONSTEXPR RoutingInfoEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingInfoEntry(const RoutingInfoEntry& from);
  RoutingInfoEntry(RoutingInfoEntry&& from) noexcept
    : RoutingInfoEntry() {
    *this = ::std::move(from);
  }

  inline RoutingInfoEntry& operator=(const RoutingInfoEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingInfoEntry& operator=(RoutingInfoEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingInfoEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingInfoEntry* internal_default_instance() {
    return reinterpret_cast<const RoutingInfoEntry*>(
               &_RoutingInfoEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RoutingInfoEntry& a, RoutingInfoEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingInfoEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingInfoEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutingInfoEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoutingInfoEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingInfoEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoutingInfoEntry& from) {
    RoutingInfoEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingInfoEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.RoutingInfoEntry";
  }
  protected:
  explicit RoutingInfoEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kHcFieldNumber = 3,
    kRttFieldNumber = 2,
    kPgidFieldNumber = 5,
  };
  // bytes user = 1;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // bytes hc = 3;
  void clear_hc();
  const std::string& hc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hc();
  PROTOBUF_NODISCARD std::string* release_hc();
  void set_allocated_hc(std::string* hc);
  private:
  const std::string& _internal_hc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hc(const std::string& value);
  std::string* _internal_mutable_hc();
  public:

  // uint32 rtt = 2;
  void clear_rtt();
  uint32_t rtt() const;
  void set_rtt(uint32_t value);
  private:
  uint32_t _internal_rtt() const;
  void _internal_set_rtt(uint32_t value);
  public:

  // uint32 pgid = 5;
  void clear_pgid();
  uint32_t pgid() const;
  void set_pgid(uint32_t value);
  private:
  uint32_t _internal_pgid() const;
  void _internal_set_pgid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.RoutingInfoEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hc_;
    uint32_t rtt_;
    uint32_t pgid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class UserIdTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.UserIdTable) */ {
 public:
  inline UserIdTable() : UserIdTable(nullptr) {}
  ~UserIdTable() override;
  explicit PROTOBUF_CONSTEXPR UserIdTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserIdTable(const UserIdTable& from);
  UserIdTable(UserIdTable&& from) noexcept
    : UserIdTable() {
    *this = ::std::move(from);
  }

  inline UserIdTable& operator=(const UserIdTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserIdTable& operator=(UserIdTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserIdTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserIdTable* internal_default_instance() {
    return reinterpret_cast<const UserIdTable*>(
               &_UserIdTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UserIdTable& a, UserIdTable& b) {
    a.Swap(&b);
  }
  inline void Swap(UserIdTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserIdTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserIdTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserIdTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserIdTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserIdTable& from) {
    UserIdTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserIdTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.UserIdTable";
  }
  protected:
  explicit UserIdTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
  };
  // repeated bytes ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  const std::string& ids(int index) const;
  std::string* mutable_ids(int index);
  void set_ids(int index, const std::string& value);
  void set_ids(int index, std::string&& value);
  void set_ids(int index, const char* value);
  void set_ids(int index, const void* value, size_t size);
  std::string* add_ids();
  void add_ids(const std::string& value);
  void add_ids(std::string&& value);
  void add_ids(const char* value);
  void add_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ids();
  private:
  const std::string& _internal_ids(int index) const;
  std::string* _internal_add_ids();
  public:

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.UserIdTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class UserInfoTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.UserInfoTable) */ {
 public:
  inline UserInfoTable() : UserInfoTable(nullptr) {}
  ~UserInfoTable() override;
  explicit PROTOBUF_CONSTEXPR UserInfoTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfoTable(const UserInfoTable& from);
  UserInfoTable(UserInfoTable&& from) noexcept
    : UserInfoTable() {
    *this = ::std::move(from);
  }

  inline UserInfoTable& operator=(const UserInfoTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfoTable& operator=(UserInfoTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfoTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfoTable* internal_default_instance() {
    return reinterpret_cast<const UserInfoTable*>(
               &_UserInfoTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UserInfoTable& a, UserInfoTable& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfoTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfoTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfoTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfoTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserInfoTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserInfoTable& from) {
    UserInfoTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfoTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.UserInfoTable";
  }
  protected:
  explicit UserInfoTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // repeated .qaul.net.router_net_info.UserInfo info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  ::qaul::net::router_net_info::UserInfo* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::UserInfo >*
      mutable_info();
  private:
  const ::qaul::net::router_net_info::UserInfo& _internal_info(int index) const;
  ::qaul::net::router_net_info::UserInfo* _internal_add_info();
  public:
  const ::qaul::net::router_net_info::UserInfo& info(int index) const;
  ::qaul::net::router_net_info::UserInfo* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::UserInfo >&
      info() const;

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.UserInfoTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::UserInfo > info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class UserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  explicit PROTOBUF_CONSTEXPR UserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserInfo& from) {
    UserInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.UserInfo";
  }
  protected:
  explicit UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kKeyFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.UserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class FeedIdsTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.FeedIdsTable) */ {
 public:
  inline FeedIdsTable() : FeedIdsTable(nullptr) {}
  ~FeedIdsTable() override;
  explicit PROTOBUF_CONSTEXPR FeedIdsTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedIdsTable(const FeedIdsTable& from);
  FeedIdsTable(FeedIdsTable&& from) noexcept
    : FeedIdsTable() {
    *this = ::std::move(from);
  }

  inline FeedIdsTable& operator=(const FeedIdsTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedIdsTable& operator=(FeedIdsTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedIdsTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedIdsTable* internal_default_instance() {
    return reinterpret_cast<const FeedIdsTable*>(
               &_FeedIdsTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FeedIdsTable& a, FeedIdsTable& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedIdsTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedIdsTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedIdsTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedIdsTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedIdsTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedIdsTable& from) {
    FeedIdsTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedIdsTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.FeedIdsTable";
  }
  protected:
  explicit FeedIdsTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
  };
  // repeated bytes ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  const std::string& ids(int index) const;
  std::string* mutable_ids(int index);
  void set_ids(int index, const std::string& value);
  void set_ids(int index, std::string&& value);
  void set_ids(int index, const char* value);
  void set_ids(int index, const void* value, size_t size);
  std::string* add_ids();
  void add_ids(const std::string& value);
  void add_ids(std::string&& value);
  void add_ids(const char* value);
  void add_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ids();
  private:
  const std::string& _internal_ids(int index) const;
  std::string* _internal_add_ids();
  public:

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.FeedIdsTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class FeedRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.FeedRequestMessage) */ {
 public:
  inline FeedRequestMessage() : FeedRequestMessage(nullptr) {}
  ~FeedRequestMessage() override;
  explicit PROTOBUF_CONSTEXPR FeedRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedRequestMessage(const FeedRequestMessage& from);
  FeedRequestMessage(FeedRequestMessage&& from) noexcept
    : FeedRequestMessage() {
    *this = ::std::move(from);
  }

  inline FeedRequestMessage& operator=(const FeedRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedRequestMessage& operator=(FeedRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedRequestMessage* internal_default_instance() {
    return reinterpret_cast<const FeedRequestMessage*>(
               &_FeedRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FeedRequestMessage& a, FeedRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedRequestMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedRequestMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedRequestMessage& from) {
    FeedRequestMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.FeedRequestMessage";
  }
  protected:
  explicit FeedRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeedsFieldNumber = 1,
  };
  // .qaul.net.router_net_info.FeedIdsTable feeds = 1;
  bool has_feeds() const;
  private:
  bool _internal_has_feeds() const;
  public:
  void clear_feeds();
  const ::qaul::net::router_net_info::FeedIdsTable& feeds() const;
  PROTOBUF_NODISCARD ::qaul::net::router_net_info::FeedIdsTable* release_feeds();
  ::qaul::net::router_net_info::FeedIdsTable* mutable_feeds();
  void set_allocated_feeds(::qaul::net::router_net_info::FeedIdsTable* feeds);
  private:
  const ::qaul::net::router_net_info::FeedIdsTable& _internal_feeds() const;
  ::qaul::net::router_net_info::FeedIdsTable* _internal_mutable_feeds();
  public:
  void unsafe_arena_set_allocated_feeds(
      ::qaul::net::router_net_info::FeedIdsTable* feeds);
  ::qaul::net::router_net_info::FeedIdsTable* unsafe_arena_release_feeds();

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.FeedRequestMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::qaul::net::router_net_info::FeedIdsTable* feeds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class FeedResponseMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.FeedResponseMessage) */ {
 public:
  inline FeedResponseMessage() : FeedResponseMessage(nullptr) {}
  ~FeedResponseMessage() override;
  explicit PROTOBUF_CONSTEXPR FeedResponseMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedResponseMessage(const FeedResponseMessage& from);
  FeedResponseMessage(FeedResponseMessage&& from) noexcept
    : FeedResponseMessage() {
    *this = ::std::move(from);
  }

  inline FeedResponseMessage& operator=(const FeedResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedResponseMessage& operator=(FeedResponseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedResponseMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedResponseMessage* internal_default_instance() {
    return reinterpret_cast<const FeedResponseMessage*>(
               &_FeedResponseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FeedResponseMessage& a, FeedResponseMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedResponseMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedResponseMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedResponseMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedResponseMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedResponseMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedResponseMessage& from) {
    FeedResponseMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedResponseMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.FeedResponseMessage";
  }
  protected:
  explicit FeedResponseMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeedsFieldNumber = 1,
  };
  // .qaul.net.router_net_info.FeedResponseTable feeds = 1;
  bool has_feeds() const;
  private:
  bool _internal_has_feeds() const;
  public:
  void clear_feeds();
  const ::qaul::net::router_net_info::FeedResponseTable& feeds() const;
  PROTOBUF_NODISCARD ::qaul::net::router_net_info::FeedResponseTable* release_feeds();
  ::qaul::net::router_net_info::FeedResponseTable* mutable_feeds();
  void set_allocated_feeds(::qaul::net::router_net_info::FeedResponseTable* feeds);
  private:
  const ::qaul::net::router_net_info::FeedResponseTable& _internal_feeds() const;
  ::qaul::net::router_net_info::FeedResponseTable* _internal_mutable_feeds();
  public:
  void unsafe_arena_set_allocated_feeds(
      ::qaul::net::router_net_info::FeedResponseTable* feeds);
  ::qaul::net::router_net_info::FeedResponseTable* unsafe_arena_release_feeds();

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.FeedResponseMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::qaul::net::router_net_info::FeedResponseTable* feeds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class FeedResponseTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.FeedResponseTable) */ {
 public:
  inline FeedResponseTable() : FeedResponseTable(nullptr) {}
  ~FeedResponseTable() override;
  explicit PROTOBUF_CONSTEXPR FeedResponseTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedResponseTable(const FeedResponseTable& from);
  FeedResponseTable(FeedResponseTable&& from) noexcept
    : FeedResponseTable() {
    *this = ::std::move(from);
  }

  inline FeedResponseTable& operator=(const FeedResponseTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedResponseTable& operator=(FeedResponseTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedResponseTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedResponseTable* internal_default_instance() {
    return reinterpret_cast<const FeedResponseTable*>(
               &_FeedResponseTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FeedResponseTable& a, FeedResponseTable& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedResponseTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedResponseTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedResponseTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedResponseTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedResponseTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedResponseTable& from) {
    FeedResponseTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedResponseTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.FeedResponseTable";
  }
  protected:
  explicit FeedResponseTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .qaul.net.router_net_info.FeedMessage messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::qaul::net::router_net_info::FeedMessage* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::FeedMessage >*
      mutable_messages();
  private:
  const ::qaul::net::router_net_info::FeedMessage& _internal_messages(int index) const;
  ::qaul::net::router_net_info::FeedMessage* _internal_add_messages();
  public:
  const ::qaul::net::router_net_info::FeedMessage& messages(int index) const;
  ::qaul::net::router_net_info::FeedMessage* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::FeedMessage >&
      messages() const;

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.FeedResponseTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::FeedMessage > messages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class FeedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.FeedMessage) */ {
 public:
  inline FeedMessage() : FeedMessage(nullptr) {}
  ~FeedMessage() override;
  explicit PROTOBUF_CONSTEXPR FeedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedMessage(const FeedMessage& from);
  FeedMessage(FeedMessage&& from) noexcept
    : FeedMessage() {
    *this = ::std::move(from);
  }

  inline FeedMessage& operator=(const FeedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedMessage& operator=(FeedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedMessage* internal_default_instance() {
    return reinterpret_cast<const FeedMessage*>(
               &_FeedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FeedMessage& a, FeedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedMessage& from) {
    FeedMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.FeedMessage";
  }
  protected:
  explicit FeedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kSenderIdFieldNumber = 2,
    kContentFieldNumber = 3,
    kTimeFieldNumber = 4,
  };
  // bytes message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // bytes sender_id = 2;
  void clear_sender_id();
  const std::string& sender_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_id();
  PROTOBUF_NODISCARD std::string* release_sender_id();
  void set_allocated_sender_id(std::string* sender_id);
  private:
  const std::string& _internal_sender_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id(const std::string& value);
  std::string* _internal_mutable_sender_id();
  public:

  // string content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // uint64 time = 4;
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.FeedMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    uint64_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RouterInfoContainer

// bytes signature = 1;
inline void RouterInfoContainer::clear_signature() {
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& RouterInfoContainer::signature() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoContainer.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouterInfoContainer::set_signature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoContainer.signature)
}
inline std::string* RouterInfoContainer::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RouterInfoContainer.signature)
  return _s;
}
inline const std::string& RouterInfoContainer::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void RouterInfoContainer::_internal_set_signature(const std::string& value) {
  
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterInfoContainer::_internal_mutable_signature() {
  
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* RouterInfoContainer::release_signature() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RouterInfoContainer.signature)
  return _impl_.signature_.Release();
}
inline void RouterInfoContainer::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RouterInfoContainer.signature)
}

// bytes message = 2;
inline void RouterInfoContainer::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RouterInfoContainer::message() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoContainer.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouterInfoContainer::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoContainer.message)
}
inline std::string* RouterInfoContainer::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RouterInfoContainer.message)
  return _s;
}
inline const std::string& RouterInfoContainer::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RouterInfoContainer::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterInfoContainer::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RouterInfoContainer::release_message() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RouterInfoContainer.message)
  return _impl_.message_.Release();
}
inline void RouterInfoContainer::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RouterInfoContainer.message)
}

// -------------------------------------------------------------------

// RouterInfoContent

// bytes id = 1;
inline void RouterInfoContent::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& RouterInfoContent::id() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoContent.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouterInfoContent::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoContent.id)
}
inline std::string* RouterInfoContent::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RouterInfoContent.id)
  return _s;
}
inline const std::string& RouterInfoContent::_internal_id() const {
  return _impl_.id_.Get();
}
inline void RouterInfoContent::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterInfoContent::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* RouterInfoContent::release_id() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RouterInfoContent.id)
  return _impl_.id_.Release();
}
inline void RouterInfoContent::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RouterInfoContent.id)
}

// .qaul.net.router_net_info.RouterInfoModule routerInfoModule = 2;
inline void RouterInfoContent::clear_routerinfomodule() {
  _impl_.routerinfomodule_ = 0;
}
inline ::qaul::net::router_net_info::RouterInfoModule RouterInfoContent::_internal_routerinfomodule() const {
  return static_cast< ::qaul::net::router_net_info::RouterInfoModule >(_impl_.routerinfomodule_);
}
inline ::qaul::net::router_net_info::RouterInfoModule RouterInfoContent::routerinfomodule() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoContent.routerInfoModule)
  return _internal_routerinfomodule();
}
inline void RouterInfoContent::_internal_set_routerinfomodule(::qaul::net::router_net_info::RouterInfoModule value) {
  
  _impl_.routerinfomodule_ = value;
}
inline void RouterInfoContent::set_routerinfomodule(::qaul::net::router_net_info::RouterInfoModule value) {
  _internal_set_routerinfomodule(value);
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoContent.routerInfoModule)
}

// bytes content = 3;
inline void RouterInfoContent::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& RouterInfoContent::content() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoContent.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouterInfoContent::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoContent.content)
}
inline std::string* RouterInfoContent::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RouterInfoContent.content)
  return _s;
}
inline const std::string& RouterInfoContent::_internal_content() const {
  return _impl_.content_.Get();
}
inline void RouterInfoContent::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterInfoContent::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* RouterInfoContent::release_content() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RouterInfoContent.content)
  return _impl_.content_.Release();
}
inline void RouterInfoContent::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RouterInfoContent.content)
}

// uint64 time = 4;
inline void RouterInfoContent::clear_time() {
  _impl_.time_ = uint64_t{0u};
}
inline uint64_t RouterInfoContent::_internal_time() const {
  return _impl_.time_;
}
inline uint64_t RouterInfoContent::time() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoContent.time)
  return _internal_time();
}
inline void RouterInfoContent::_internal_set_time(uint64_t value) {
  
  _impl_.time_ = value;
}
inline void RouterInfoContent::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoContent.time)
}

// -------------------------------------------------------------------

// RouterInfoMessage

// bytes node = 1;
inline void RouterInfoMessage::clear_node() {
  _impl_.node_.ClearToEmpty();
}
inline const std::string& RouterInfoMessage::node() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoMessage.node)
  return _internal_node();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouterInfoMessage::set_node(ArgT0&& arg0, ArgT... args) {
 
 _impl_.node_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoMessage.node)
}
inline std::string* RouterInfoMessage::mutable_node() {
  std::string* _s = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RouterInfoMessage.node)
  return _s;
}
inline const std::string& RouterInfoMessage::_internal_node() const {
  return _impl_.node_.Get();
}
inline void RouterInfoMessage::_internal_set_node(const std::string& value) {
  
  _impl_.node_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterInfoMessage::_internal_mutable_node() {
  
  return _impl_.node_.Mutable(GetArenaForAllocation());
}
inline std::string* RouterInfoMessage::release_node() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RouterInfoMessage.node)
  return _impl_.node_.Release();
}
inline void RouterInfoMessage::set_allocated_node(std::string* node) {
  if (node != nullptr) {
    
  } else {
    
  }
  _impl_.node_.SetAllocated(node, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_.IsDefault()) {
    _impl_.node_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RouterInfoMessage.node)
}

// .qaul.net.router_net_info.RoutingInfoTable routes = 2;
inline bool RouterInfoMessage::_internal_has_routes() const {
  return this != internal_default_instance() && _impl_.routes_ != nullptr;
}
inline bool RouterInfoMessage::has_routes() const {
  return _internal_has_routes();
}
inline void RouterInfoMessage::clear_routes() {
  if (GetArenaForAllocation() == nullptr && _impl_.routes_ != nullptr) {
    delete _impl_.routes_;
  }
  _impl_.routes_ = nullptr;
}
inline const ::qaul::net::router_net_info::RoutingInfoTable& RouterInfoMessage::_internal_routes() const {
  const ::qaul::net::router_net_info::RoutingInfoTable* p = _impl_.routes_;
  return p != nullptr ? *p : reinterpret_cast<const ::qaul::net::router_net_info::RoutingInfoTable&>(
      ::qaul::net::router_net_info::_RoutingInfoTable_default_instance_);
}
inline const ::qaul::net::router_net_info::RoutingInfoTable& RouterInfoMessage::routes() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoMessage.routes)
  return _internal_routes();
}
inline void RouterInfoMessage::unsafe_arena_set_allocated_routes(
    ::qaul::net::router_net_info::RoutingInfoTable* routes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.routes_);
  }
  _impl_.routes_ = routes;
  if (routes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.net.router_net_info.RouterInfoMessage.routes)
}
inline ::qaul::net::router_net_info::RoutingInfoTable* RouterInfoMessage::release_routes() {
  
  ::qaul::net::router_net_info::RoutingInfoTable* temp = _impl_.routes_;
  _impl_.routes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::qaul::net::router_net_info::RoutingInfoTable* RouterInfoMessage::unsafe_arena_release_routes() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RouterInfoMessage.routes)
  
  ::qaul::net::router_net_info::RoutingInfoTable* temp = _impl_.routes_;
  _impl_.routes_ = nullptr;
  return temp;
}
inline ::qaul::net::router_net_info::RoutingInfoTable* RouterInfoMessage::_internal_mutable_routes() {
  
  if (_impl_.routes_ == nullptr) {
    auto* p = CreateMaybeMessage<::qaul::net::router_net_info::RoutingInfoTable>(GetArenaForAllocation());
    _impl_.routes_ = p;
  }
  return _impl_.routes_;
}
inline ::qaul::net::router_net_info::RoutingInfoTable* RouterInfoMessage::mutable_routes() {
  ::qaul::net::router_net_info::RoutingInfoTable* _msg = _internal_mutable_routes();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RouterInfoMessage.routes)
  return _msg;
}
inline void RouterInfoMessage::set_allocated_routes(::qaul::net::router_net_info::RoutingInfoTable* routes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.routes_;
  }
  if (routes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(routes);
    if (message_arena != submessage_arena) {
      routes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.routes_ = routes;
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RouterInfoMessage.routes)
}

// .qaul.net.router_net_info.FeedIdsTable feeds = 4;
inline bool RouterInfoMessage::_internal_has_feeds() const {
  return this != internal_default_instance() && _impl_.feeds_ != nullptr;
}
inline bool RouterInfoMessage::has_feeds() const {
  return _internal_has_feeds();
}
inline void RouterInfoMessage::clear_feeds() {
  if (GetArenaForAllocation() == nullptr && _impl_.feeds_ != nullptr) {
    delete _impl_.feeds_;
  }
  _impl_.feeds_ = nullptr;
}
inline const ::qaul::net::router_net_info::FeedIdsTable& RouterInfoMessage::_internal_feeds() const {
  const ::qaul::net::router_net_info::FeedIdsTable* p = _impl_.feeds_;
  return p != nullptr ? *p : reinterpret_cast<const ::qaul::net::router_net_info::FeedIdsTable&>(
      ::qaul::net::router_net_info::_FeedIdsTable_default_instance_);
}
inline const ::qaul::net::router_net_info::FeedIdsTable& RouterInfoMessage::feeds() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoMessage.feeds)
  return _internal_feeds();
}
inline void RouterInfoMessage::unsafe_arena_set_allocated_feeds(
    ::qaul::net::router_net_info::FeedIdsTable* feeds) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.feeds_);
  }
  _impl_.feeds_ = feeds;
  if (feeds) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.net.router_net_info.RouterInfoMessage.feeds)
}
inline ::qaul::net::router_net_info::FeedIdsTable* RouterInfoMessage::release_feeds() {
  
  ::qaul::net::router_net_info::FeedIdsTable* temp = _impl_.feeds_;
  _impl_.feeds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::qaul::net::router_net_info::FeedIdsTable* RouterInfoMessage::unsafe_arena_release_feeds() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RouterInfoMessage.feeds)
  
  ::qaul::net::router_net_info::FeedIdsTable* temp = _impl_.feeds_;
  _impl_.feeds_ = nullptr;
  return temp;
}
inline ::qaul::net::router_net_info::FeedIdsTable* RouterInfoMessage::_internal_mutable_feeds() {
  
  if (_impl_.feeds_ == nullptr) {
    auto* p = CreateMaybeMessage<::qaul::net::router_net_info::FeedIdsTable>(GetArenaForAllocation());
    _impl_.feeds_ = p;
  }
  return _impl_.feeds_;
}
inline ::qaul::net::router_net_info::FeedIdsTable* RouterInfoMessage::mutable_feeds() {
  ::qaul::net::router_net_info::FeedIdsTable* _msg = _internal_mutable_feeds();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RouterInfoMessage.feeds)
  return _msg;
}
inline void RouterInfoMessage::set_allocated_feeds(::qaul::net::router_net_info::FeedIdsTable* feeds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.feeds_;
  }
  if (feeds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feeds);
    if (message_arena != submessage_arena) {
      feeds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feeds, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.feeds_ = feeds;
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RouterInfoMessage.feeds)
}

// uint64 timestamp = 5;
inline void RouterInfoMessage::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t RouterInfoMessage::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t RouterInfoMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoMessage.timestamp)
  return _internal_timestamp();
}
inline void RouterInfoMessage::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void RouterInfoMessage::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoMessage.timestamp)
}

// -------------------------------------------------------------------

// RoutingInfoTable

// repeated .qaul.net.router_net_info.RoutingInfoEntry entry = 1;
inline int RoutingInfoTable::_internal_entry_size() const {
  return _impl_.entry_.size();
}
inline int RoutingInfoTable::entry_size() const {
  return _internal_entry_size();
}
inline void RoutingInfoTable::clear_entry() {
  _impl_.entry_.Clear();
}
inline ::qaul::net::router_net_info::RoutingInfoEntry* RoutingInfoTable::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RoutingInfoTable.entry)
  return _impl_.entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::RoutingInfoEntry >*
RoutingInfoTable::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:qaul.net.router_net_info.RoutingInfoTable.entry)
  return &_impl_.entry_;
}
inline const ::qaul::net::router_net_info::RoutingInfoEntry& RoutingInfoTable::_internal_entry(int index) const {
  return _impl_.entry_.Get(index);
}
inline const ::qaul::net::router_net_info::RoutingInfoEntry& RoutingInfoTable::entry(int index) const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RoutingInfoTable.entry)
  return _internal_entry(index);
}
inline ::qaul::net::router_net_info::RoutingInfoEntry* RoutingInfoTable::_internal_add_entry() {
  return _impl_.entry_.Add();
}
inline ::qaul::net::router_net_info::RoutingInfoEntry* RoutingInfoTable::add_entry() {
  ::qaul::net::router_net_info::RoutingInfoEntry* _add = _internal_add_entry();
  // @@protoc_insertion_point(field_add:qaul.net.router_net_info.RoutingInfoTable.entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::RoutingInfoEntry >&
RoutingInfoTable::entry() const {
  // @@protoc_insertion_point(field_list:qaul.net.router_net_info.RoutingInfoTable.entry)
  return _impl_.entry_;
}

// -------------------------------------------------------------------

// RoutingInfoEntry

// bytes user = 1;
inline void RoutingInfoEntry::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& RoutingInfoEntry::user() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RoutingInfoEntry.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoutingInfoEntry::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RoutingInfoEntry.user)
}
inline std::string* RoutingInfoEntry::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RoutingInfoEntry.user)
  return _s;
}
inline const std::string& RoutingInfoEntry::_internal_user() const {
  return _impl_.user_.Get();
}
inline void RoutingInfoEntry::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* RoutingInfoEntry::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* RoutingInfoEntry::release_user() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RoutingInfoEntry.user)
  return _impl_.user_.Release();
}
inline void RoutingInfoEntry::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RoutingInfoEntry.user)
}

// uint32 rtt = 2;
inline void RoutingInfoEntry::clear_rtt() {
  _impl_.rtt_ = 0u;
}
inline uint32_t RoutingInfoEntry::_internal_rtt() const {
  return _impl_.rtt_;
}
inline uint32_t RoutingInfoEntry::rtt() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RoutingInfoEntry.rtt)
  return _internal_rtt();
}
inline void RoutingInfoEntry::_internal_set_rtt(uint32_t value) {
  
  _impl_.rtt_ = value;
}
inline void RoutingInfoEntry::set_rtt(uint32_t value) {
  _internal_set_rtt(value);
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RoutingInfoEntry.rtt)
}

// bytes hc = 3;
inline void RoutingInfoEntry::clear_hc() {
  _impl_.hc_.ClearToEmpty();
}
inline const std::string& RoutingInfoEntry::hc() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RoutingInfoEntry.hc)
  return _internal_hc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoutingInfoEntry::set_hc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hc_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RoutingInfoEntry.hc)
}
inline std::string* RoutingInfoEntry::mutable_hc() {
  std::string* _s = _internal_mutable_hc();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RoutingInfoEntry.hc)
  return _s;
}
inline const std::string& RoutingInfoEntry::_internal_hc() const {
  return _impl_.hc_.Get();
}
inline void RoutingInfoEntry::_internal_set_hc(const std::string& value) {
  
  _impl_.hc_.Set(value, GetArenaForAllocation());
}
inline std::string* RoutingInfoEntry::_internal_mutable_hc() {
  
  return _impl_.hc_.Mutable(GetArenaForAllocation());
}
inline std::string* RoutingInfoEntry::release_hc() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RoutingInfoEntry.hc)
  return _impl_.hc_.Release();
}
inline void RoutingInfoEntry::set_allocated_hc(std::string* hc) {
  if (hc != nullptr) {
    
  } else {
    
  }
  _impl_.hc_.SetAllocated(hc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hc_.IsDefault()) {
    _impl_.hc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RoutingInfoEntry.hc)
}

// uint32 pgid = 5;
inline void RoutingInfoEntry::clear_pgid() {
  _impl_.pgid_ = 0u;
}
inline uint32_t RoutingInfoEntry::_internal_pgid() const {
  return _impl_.pgid_;
}
inline uint32_t RoutingInfoEntry::pgid() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RoutingInfoEntry.pgid)
  return _internal_pgid();
}
inline void RoutingInfoEntry::_internal_set_pgid(uint32_t value) {
  
  _impl_.pgid_ = value;
}
inline void RoutingInfoEntry::set_pgid(uint32_t value) {
  _internal_set_pgid(value);
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RoutingInfoEntry.pgid)
}

// -------------------------------------------------------------------

// UserIdTable

// repeated bytes ids = 1;
inline int UserIdTable::_internal_ids_size() const {
  return _impl_.ids_.size();
}
inline int UserIdTable::ids_size() const {
  return _internal_ids_size();
}
inline void UserIdTable::clear_ids() {
  _impl_.ids_.Clear();
}
inline std::string* UserIdTable::add_ids() {
  std::string* _s = _internal_add_ids();
  // @@protoc_insertion_point(field_add_mutable:qaul.net.router_net_info.UserIdTable.ids)
  return _s;
}
inline const std::string& UserIdTable::_internal_ids(int index) const {
  return _impl_.ids_.Get(index);
}
inline const std::string& UserIdTable::ids(int index) const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.UserIdTable.ids)
  return _internal_ids(index);
}
inline std::string* UserIdTable::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.UserIdTable.ids)
  return _impl_.ids_.Mutable(index);
}
inline void UserIdTable::set_ids(int index, const std::string& value) {
  _impl_.ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.UserIdTable.ids)
}
inline void UserIdTable::set_ids(int index, std::string&& value) {
  _impl_.ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.UserIdTable.ids)
}
inline void UserIdTable::set_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:qaul.net.router_net_info.UserIdTable.ids)
}
inline void UserIdTable::set_ids(int index, const void* value, size_t size) {
  _impl_.ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qaul.net.router_net_info.UserIdTable.ids)
}
inline std::string* UserIdTable::_internal_add_ids() {
  return _impl_.ids_.Add();
}
inline void UserIdTable::add_ids(const std::string& value) {
  _impl_.ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:qaul.net.router_net_info.UserIdTable.ids)
}
inline void UserIdTable::add_ids(std::string&& value) {
  _impl_.ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:qaul.net.router_net_info.UserIdTable.ids)
}
inline void UserIdTable::add_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:qaul.net.router_net_info.UserIdTable.ids)
}
inline void UserIdTable::add_ids(const void* value, size_t size) {
  _impl_.ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:qaul.net.router_net_info.UserIdTable.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UserIdTable::ids() const {
  // @@protoc_insertion_point(field_list:qaul.net.router_net_info.UserIdTable.ids)
  return _impl_.ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UserIdTable::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:qaul.net.router_net_info.UserIdTable.ids)
  return &_impl_.ids_;
}

// -------------------------------------------------------------------

// UserInfoTable

// repeated .qaul.net.router_net_info.UserInfo info = 1;
inline int UserInfoTable::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int UserInfoTable::info_size() const {
  return _internal_info_size();
}
inline void UserInfoTable::clear_info() {
  _impl_.info_.Clear();
}
inline ::qaul::net::router_net_info::UserInfo* UserInfoTable::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.UserInfoTable.info)
  return _impl_.info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::UserInfo >*
UserInfoTable::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:qaul.net.router_net_info.UserInfoTable.info)
  return &_impl_.info_;
}
inline const ::qaul::net::router_net_info::UserInfo& UserInfoTable::_internal_info(int index) const {
  return _impl_.info_.Get(index);
}
inline const ::qaul::net::router_net_info::UserInfo& UserInfoTable::info(int index) const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.UserInfoTable.info)
  return _internal_info(index);
}
inline ::qaul::net::router_net_info::UserInfo* UserInfoTable::_internal_add_info() {
  return _impl_.info_.Add();
}
inline ::qaul::net::router_net_info::UserInfo* UserInfoTable::add_info() {
  ::qaul::net::router_net_info::UserInfo* _add = _internal_add_info();
  // @@protoc_insertion_point(field_add:qaul.net.router_net_info.UserInfoTable.info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::UserInfo >&
UserInfoTable::info() const {
  // @@protoc_insertion_point(field_list:qaul.net.router_net_info.UserInfoTable.info)
  return _impl_.info_;
}

// -------------------------------------------------------------------

// UserInfo

// bytes id = 1;
inline void UserInfo::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& UserInfo::id() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.UserInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.UserInfo.id)
}
inline std::string* UserInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.UserInfo.id)
  return _s;
}
inline const std::string& UserInfo::_internal_id() const {
  return _impl_.id_.Get();
}
inline void UserInfo::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_id() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.UserInfo.id)
  return _impl_.id_.Release();
}
inline void UserInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.UserInfo.id)
}

// bytes key = 2;
inline void UserInfo::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& UserInfo::key() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.UserInfo.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.UserInfo.key)
}
inline std::string* UserInfo::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.UserInfo.key)
  return _s;
}
inline const std::string& UserInfo::_internal_key() const {
  return _impl_.key_.Get();
}
inline void UserInfo::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_key() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.UserInfo.key)
  return _impl_.key_.Release();
}
inline void UserInfo::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.UserInfo.key)
}

// string name = 3;
inline void UserInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UserInfo::name() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.UserInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.UserInfo.name)
}
inline std::string* UserInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.UserInfo.name)
  return _s;
}
inline const std::string& UserInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UserInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_name() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.UserInfo.name)
  return _impl_.name_.Release();
}
inline void UserInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.UserInfo.name)
}

// -------------------------------------------------------------------

// FeedIdsTable

// repeated bytes ids = 1;
inline int FeedIdsTable::_internal_ids_size() const {
  return _impl_.ids_.size();
}
inline int FeedIdsTable::ids_size() const {
  return _internal_ids_size();
}
inline void FeedIdsTable::clear_ids() {
  _impl_.ids_.Clear();
}
inline std::string* FeedIdsTable::add_ids() {
  std::string* _s = _internal_add_ids();
  // @@protoc_insertion_point(field_add_mutable:qaul.net.router_net_info.FeedIdsTable.ids)
  return _s;
}
inline const std::string& FeedIdsTable::_internal_ids(int index) const {
  return _impl_.ids_.Get(index);
}
inline const std::string& FeedIdsTable::ids(int index) const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.FeedIdsTable.ids)
  return _internal_ids(index);
}
inline std::string* FeedIdsTable::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.FeedIdsTable.ids)
  return _impl_.ids_.Mutable(index);
}
inline void FeedIdsTable::set_ids(int index, const std::string& value) {
  _impl_.ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.FeedIdsTable.ids)
}
inline void FeedIdsTable::set_ids(int index, std::string&& value) {
  _impl_.ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.FeedIdsTable.ids)
}
inline void FeedIdsTable::set_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:qaul.net.router_net_info.FeedIdsTable.ids)
}
inline void FeedIdsTable::set_ids(int index, const void* value, size_t size) {
  _impl_.ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qaul.net.router_net_info.FeedIdsTable.ids)
}
inline std::string* FeedIdsTable::_internal_add_ids() {
  return _impl_.ids_.Add();
}
inline void FeedIdsTable::add_ids(const std::string& value) {
  _impl_.ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:qaul.net.router_net_info.FeedIdsTable.ids)
}
inline void FeedIdsTable::add_ids(std::string&& value) {
  _impl_.ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:qaul.net.router_net_info.FeedIdsTable.ids)
}
inline void FeedIdsTable::add_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:qaul.net.router_net_info.FeedIdsTable.ids)
}
inline void FeedIdsTable::add_ids(const void* value, size_t size) {
  _impl_.ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:qaul.net.router_net_info.FeedIdsTable.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FeedIdsTable::ids() const {
  // @@protoc_insertion_point(field_list:qaul.net.router_net_info.FeedIdsTable.ids)
  return _impl_.ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FeedIdsTable::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:qaul.net.router_net_info.FeedIdsTable.ids)
  return &_impl_.ids_;
}

// -------------------------------------------------------------------

// FeedRequestMessage

// .qaul.net.router_net_info.FeedIdsTable feeds = 1;
inline bool FeedRequestMessage::_internal_has_feeds() const {
  return this != internal_default_instance() && _impl_.feeds_ != nullptr;
}
inline bool FeedRequestMessage::has_feeds() const {
  return _internal_has_feeds();
}
inline void FeedRequestMessage::clear_feeds() {
  if (GetArenaForAllocation() == nullptr && _impl_.feeds_ != nullptr) {
    delete _impl_.feeds_;
  }
  _impl_.feeds_ = nullptr;
}
inline const ::qaul::net::router_net_info::FeedIdsTable& FeedRequestMessage::_internal_feeds() const {
  const ::qaul::net::router_net_info::FeedIdsTable* p = _impl_.feeds_;
  return p != nullptr ? *p : reinterpret_cast<const ::qaul::net::router_net_info::FeedIdsTable&>(
      ::qaul::net::router_net_info::_FeedIdsTable_default_instance_);
}
inline const ::qaul::net::router_net_info::FeedIdsTable& FeedRequestMessage::feeds() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.FeedRequestMessage.feeds)
  return _internal_feeds();
}
inline void FeedRequestMessage::unsafe_arena_set_allocated_feeds(
    ::qaul::net::router_net_info::FeedIdsTable* feeds) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.feeds_);
  }
  _impl_.feeds_ = feeds;
  if (feeds) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.net.router_net_info.FeedRequestMessage.feeds)
}
inline ::qaul::net::router_net_info::FeedIdsTable* FeedRequestMessage::release_feeds() {
  
  ::qaul::net::router_net_info::FeedIdsTable* temp = _impl_.feeds_;
  _impl_.feeds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::qaul::net::router_net_info::FeedIdsTable* FeedRequestMessage::unsafe_arena_release_feeds() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.FeedRequestMessage.feeds)
  
  ::qaul::net::router_net_info::FeedIdsTable* temp = _impl_.feeds_;
  _impl_.feeds_ = nullptr;
  return temp;
}
inline ::qaul::net::router_net_info::FeedIdsTable* FeedRequestMessage::_internal_mutable_feeds() {
  
  if (_impl_.feeds_ == nullptr) {
    auto* p = CreateMaybeMessage<::qaul::net::router_net_info::FeedIdsTable>(GetArenaForAllocation());
    _impl_.feeds_ = p;
  }
  return _impl_.feeds_;
}
inline ::qaul::net::router_net_info::FeedIdsTable* FeedRequestMessage::mutable_feeds() {
  ::qaul::net::router_net_info::FeedIdsTable* _msg = _internal_mutable_feeds();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.FeedRequestMessage.feeds)
  return _msg;
}
inline void FeedRequestMessage::set_allocated_feeds(::qaul::net::router_net_info::FeedIdsTable* feeds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.feeds_;
  }
  if (feeds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feeds);
    if (message_arena != submessage_arena) {
      feeds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feeds, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.feeds_ = feeds;
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.FeedRequestMessage.feeds)
}

// -------------------------------------------------------------------

// FeedResponseMessage

// .qaul.net.router_net_info.FeedResponseTable feeds = 1;
inline bool FeedResponseMessage::_internal_has_feeds() const {
  return this != internal_default_instance() && _impl_.feeds_ != nullptr;
}
inline bool FeedResponseMessage::has_feeds() const {
  return _internal_has_feeds();
}
inline void FeedResponseMessage::clear_feeds() {
  if (GetArenaForAllocation() == nullptr && _impl_.feeds_ != nullptr) {
    delete _impl_.feeds_;
  }
  _impl_.feeds_ = nullptr;
}
inline const ::qaul::net::router_net_info::FeedResponseTable& FeedResponseMessage::_internal_feeds() const {
  const ::qaul::net::router_net_info::FeedResponseTable* p = _impl_.feeds_;
  return p != nullptr ? *p : reinterpret_cast<const ::qaul::net::router_net_info::FeedResponseTable&>(
      ::qaul::net::router_net_info::_FeedResponseTable_default_instance_);
}
inline const ::qaul::net::router_net_info::FeedResponseTable& FeedResponseMessage::feeds() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.FeedResponseMessage.feeds)
  return _internal_feeds();
}
inline void FeedResponseMessage::unsafe_arena_set_allocated_feeds(
    ::qaul::net::router_net_info::FeedResponseTable* feeds) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.feeds_);
  }
  _impl_.feeds_ = feeds;
  if (feeds) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.net.router_net_info.FeedResponseMessage.feeds)
}
inline ::qaul::net::router_net_info::FeedResponseTable* FeedResponseMessage::release_feeds() {
  
  ::qaul::net::router_net_info::FeedResponseTable* temp = _impl_.feeds_;
  _impl_.feeds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::qaul::net::router_net_info::FeedResponseTable* FeedResponseMessage::unsafe_arena_release_feeds() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.FeedResponseMessage.feeds)
  
  ::qaul::net::router_net_info::FeedResponseTable* temp = _impl_.feeds_;
  _impl_.feeds_ = nullptr;
  return temp;
}
inline ::qaul::net::router_net_info::FeedResponseTable* FeedResponseMessage::_internal_mutable_feeds() {
  
  if (_impl_.feeds_ == nullptr) {
    auto* p = CreateMaybeMessage<::qaul::net::router_net_info::FeedResponseTable>(GetArenaForAllocation());
    _impl_.feeds_ = p;
  }
  return _impl_.feeds_;
}
inline ::qaul::net::router_net_info::FeedResponseTable* FeedResponseMessage::mutable_feeds() {
  ::qaul::net::router_net_info::FeedResponseTable* _msg = _internal_mutable_feeds();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.FeedResponseMessage.feeds)
  return _msg;
}
inline void FeedResponseMessage::set_allocated_feeds(::qaul::net::router_net_info::FeedResponseTable* feeds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.feeds_;
  }
  if (feeds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feeds);
    if (message_arena != submessage_arena) {
      feeds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feeds, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.feeds_ = feeds;
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.FeedResponseMessage.feeds)
}

// -------------------------------------------------------------------

// FeedResponseTable

// repeated .qaul.net.router_net_info.FeedMessage messages = 1;
inline int FeedResponseTable::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int FeedResponseTable::messages_size() const {
  return _internal_messages_size();
}
inline void FeedResponseTable::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::qaul::net::router_net_info::FeedMessage* FeedResponseTable::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.FeedResponseTable.messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::FeedMessage >*
FeedResponseTable::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:qaul.net.router_net_info.FeedResponseTable.messages)
  return &_impl_.messages_;
}
inline const ::qaul::net::router_net_info::FeedMessage& FeedResponseTable::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::qaul::net::router_net_info::FeedMessage& FeedResponseTable::messages(int index) const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.FeedResponseTable.messages)
  return _internal_messages(index);
}
inline ::qaul::net::router_net_info::FeedMessage* FeedResponseTable::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::qaul::net::router_net_info::FeedMessage* FeedResponseTable::add_messages() {
  ::qaul::net::router_net_info::FeedMessage* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:qaul.net.router_net_info.FeedResponseTable.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::FeedMessage >&
FeedResponseTable::messages() const {
  // @@protoc_insertion_point(field_list:qaul.net.router_net_info.FeedResponseTable.messages)
  return _impl_.messages_;
}

// -------------------------------------------------------------------

// FeedMessage

// bytes message_id = 1;
inline void FeedMessage::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& FeedMessage::message_id() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.FeedMessage.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedMessage::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.FeedMessage.message_id)
}
inline std::string* FeedMessage::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.FeedMessage.message_id)
  return _s;
}
inline const std::string& FeedMessage::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void FeedMessage::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedMessage::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedMessage::release_message_id() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.FeedMessage.message_id)
  return _impl_.message_id_.Release();
}
inline void FeedMessage::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.FeedMessage.message_id)
}

// bytes sender_id = 2;
inline void FeedMessage::clear_sender_id() {
  _impl_.sender_id_.ClearToEmpty();
}
inline const std::string& FeedMessage::sender_id() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.FeedMessage.sender_id)
  return _internal_sender_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedMessage::set_sender_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sender_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.FeedMessage.sender_id)
}
inline std::string* FeedMessage::mutable_sender_id() {
  std::string* _s = _internal_mutable_sender_id();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.FeedMessage.sender_id)
  return _s;
}
inline const std::string& FeedMessage::_internal_sender_id() const {
  return _impl_.sender_id_.Get();
}
inline void FeedMessage::_internal_set_sender_id(const std::string& value) {
  
  _impl_.sender_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedMessage::_internal_mutable_sender_id() {
  
  return _impl_.sender_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedMessage::release_sender_id() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.FeedMessage.sender_id)
  return _impl_.sender_id_.Release();
}
inline void FeedMessage::set_allocated_sender_id(std::string* sender_id) {
  if (sender_id != nullptr) {
    
  } else {
    
  }
  _impl_.sender_id_.SetAllocated(sender_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_id_.IsDefault()) {
    _impl_.sender_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.FeedMessage.sender_id)
}

// string content = 3;
inline void FeedMessage::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& FeedMessage::content() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.FeedMessage.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedMessage::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.FeedMessage.content)
}
inline std::string* FeedMessage::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.FeedMessage.content)
  return _s;
}
inline const std::string& FeedMessage::_internal_content() const {
  return _impl_.content_.Get();
}
inline void FeedMessage::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedMessage::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedMessage::release_content() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.FeedMessage.content)
  return _impl_.content_.Release();
}
inline void FeedMessage::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.FeedMessage.content)
}

// uint64 time = 4;
inline void FeedMessage::clear_time() {
  _impl_.time_ = uint64_t{0u};
}
inline uint64_t FeedMessage::_internal_time() const {
  return _impl_.time_;
}
inline uint64_t FeedMessage::time() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.FeedMessage.time)
  return _internal_time();
}
inline void FeedMessage::_internal_set_time(uint64_t value) {
  
  _impl_.time_ = value;
}
inline void FeedMessage::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.FeedMessage.time)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace router_net_info
}  // namespace net
}  // namespace qaul

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::qaul::net::router_net_info::RouterInfoModule> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::qaul::net::router_net_info::RouterInfoModule>() {
  return ::qaul::net::router_net_info::RouterInfoModule_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_router_2frouter_5fnet_5finfo_2eproto
