// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/messaging/messaging.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// state of the crypto session
enum Qaul_Net_Messaging_CryptoState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// no crypto at all
  case none // = 0

  /// crypto session is in handshake state
  case handshake // = 1

  /// crypto session is in transport state
  case transport // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .handshake
    case 2: self = .transport
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .handshake: return 1
    case .transport: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Qaul_Net_Messaging_CryptoState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Qaul_Net_Messaging_CryptoState] = [
    .none,
    .handshake,
    .transport,
  ]
}

#endif  // swift(>=4.2)

/// qaul network messaging service
///
/// is responsible to distribute messages to users
/// the container contains the entire message with signature
struct Qaul_Net_Messaging_Container {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// signed by sending user
  var signature: Data = Data()

  /// Message envelope
  var envelope: Qaul_Net_Messaging_Envelope {
    get {return _envelope ?? Qaul_Net_Messaging_Envelope()}
    set {_envelope = newValue}
  }
  /// Returns true if `envelope` has been explicitly set.
  var hasEnvelope: Bool {return self._envelope != nil}
  /// Clears the value of `envelope`. Subsequent reads from it will return its default value.
  mutating func clearEnvelope() {self._envelope = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _envelope: Qaul_Net_Messaging_Envelope? = nil
}

/// message envelop with sender and receiver
struct Qaul_Net_Messaging_Envelope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the qaul ID of the sender
  var senderID: Data = Data()

  /// the qaul ID of the receiver
  var receiverID: Data = Data()

  /// payload
  var payload: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// envelop payload
struct Qaul_Net_Messaging_EnvelopPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Qaul_Net_Messaging_EnvelopPayload.OneOf_Payload? = nil

  /// encrypted message data
  var encrypted: Qaul_Net_Messaging_Encrypted {
    get {
      if case .encrypted(let v)? = payload {return v}
      return Qaul_Net_Messaging_Encrypted()
    }
    set {payload = .encrypted(newValue)}
  }

  /// DTN message
  var dtn: Data {
    get {
      if case .dtn(let v)? = payload {return v}
      return Data()
    }
    set {payload = .dtn(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable {
    /// encrypted message data
    case encrypted(Qaul_Net_Messaging_Encrypted)
    /// DTN message
    case dtn(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Qaul_Net_Messaging_EnvelopPayload.OneOf_Payload, rhs: Qaul_Net_Messaging_EnvelopPayload.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.encrypted, .encrypted): return {
        guard case .encrypted(let l) = lhs, case .encrypted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dtn, .dtn): return {
        guard case .dtn(let l) = lhs, case .dtn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// encrypted message data
struct Qaul_Net_Messaging_Encrypted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// state of the crypto session
  var state: Qaul_Net_Messaging_CryptoState = .none

  /// crypto session id
  var sessionID: UInt32 = 0

  /// one or several Data messages
  /// of maximally 64KB each.
  var data: [Qaul_Net_Messaging_Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// encrypted message data
struct Qaul_Net_Messaging_Data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message nonce for encryption
  ///
  /// each nonce is only used once per key
  /// and increases by one fore each new data package.
  var nonce: UInt64 = 0

  /// the encrypted message data slice
  /// each data package contains maximally
  /// 64KB
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// messaging unified message
struct Qaul_Net_Messaging_Messaging {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: Qaul_Net_Messaging_Messaging.OneOf_Message? = nil

  /// confirm chat message
  var confirmationMessage: Qaul_Net_Messaging_Confirmation {
    get {
      if case .confirmationMessage(let v)? = message {return v}
      return Qaul_Net_Messaging_Confirmation()
    }
    set {message = .confirmationMessage(newValue)}
  }

  /// dtn response message
  var dtnResponse: Qaul_Net_Messaging_DtnResponse {
    get {
      if case .dtnResponse(let v)? = message {return v}
      return Qaul_Net_Messaging_DtnResponse()
    }
    set {message = .dtnResponse(newValue)}
  }

  /// crypto service
  var cryptoService: Qaul_Net_Messaging_CryptoService {
    get {
      if case .cryptoService(let v)? = message {return v}
      return Qaul_Net_Messaging_CryptoService()
    }
    set {message = .cryptoService(newValue)}
  }

  /// rtc stream
  var rtcStreamMessage: Qaul_Net_Messaging_RtcStreamMessage {
    get {
      if case .rtcStreamMessage(let v)? = message {return v}
      return Qaul_Net_Messaging_RtcStreamMessage()
    }
    set {message = .rtcStreamMessage(newValue)}
  }

  /// group invite messages
  var groupInviteMessage: Qaul_Net_Messaging_GroupInviteMessage {
    get {
      if case .groupInviteMessage(let v)? = message {return v}
      return Qaul_Net_Messaging_GroupInviteMessage()
    }
    set {message = .groupInviteMessage(newValue)}
  }

  /// common message
  var commonMessage: Qaul_Net_Messaging_CommonMessage {
    get {
      if case .commonMessage(let v)? = message {return v}
      return Qaul_Net_Messaging_CommonMessage()
    }
    set {message = .commonMessage(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    /// confirm chat message
    case confirmationMessage(Qaul_Net_Messaging_Confirmation)
    /// dtn response message
    case dtnResponse(Qaul_Net_Messaging_DtnResponse)
    /// crypto service
    case cryptoService(Qaul_Net_Messaging_CryptoService)
    /// rtc stream
    case rtcStreamMessage(Qaul_Net_Messaging_RtcStreamMessage)
    /// group invite messages
    case groupInviteMessage(Qaul_Net_Messaging_GroupInviteMessage)
    /// common message
    case commonMessage(Qaul_Net_Messaging_CommonMessage)

  #if !swift(>=4.1)
    static func ==(lhs: Qaul_Net_Messaging_Messaging.OneOf_Message, rhs: Qaul_Net_Messaging_Messaging.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.confirmationMessage, .confirmationMessage): return {
        guard case .confirmationMessage(let l) = lhs, case .confirmationMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dtnResponse, .dtnResponse): return {
        guard case .dtnResponse(let l) = lhs, case .dtnResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cryptoService, .cryptoService): return {
        guard case .cryptoService(let l) = lhs, case .cryptoService(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rtcStreamMessage, .rtcStreamMessage): return {
        guard case .rtcStreamMessage(let l) = lhs, case .rtcStreamMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupInviteMessage, .groupInviteMessage): return {
        guard case .groupInviteMessage(let l) = lhs, case .groupInviteMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.commonMessage, .commonMessage): return {
        guard case .commonMessage(let l) = lhs, case .commonMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// message received confirmation
///
/// every message that was received by a user
/// sends an acknowledgment package, to the sender
/// to confirm the receive.
struct Qaul_Net_Messaging_Confirmation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message ID
  var signature: Data = Data()

  /// received at timestamp
  var receivedAt: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Crypto Service Message
///
/// This message is for crypto specific tasks,
/// such as completing a handshake.
struct Qaul_Net_Messaging_CryptoService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// rtc stream mesasge
struct Qaul_Net_Messaging_RtcStreamMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// group invite message
struct Qaul_Net_Messaging_GroupInviteMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// common message
struct Qaul_Net_Messaging_CommonMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message ID
  var messageID: Data = Data()

  /// group id
  var groupID: Data = Data()

  /// sent at timestamp
  var sentAt: UInt64 = 0

  /// payload
  var payload: Qaul_Net_Messaging_CommonMessage.OneOf_Payload? = nil

  /// chat message
  var chatMessage: Qaul_Net_Messaging_ChatMessage {
    get {
      if case .chatMessage(let v)? = payload {return v}
      return Qaul_Net_Messaging_ChatMessage()
    }
    set {payload = .chatMessage(newValue)}
  }

  /// file message
  var fileMessage: Qaul_Net_Messaging_FileMessage {
    get {
      if case .fileMessage(let v)? = payload {return v}
      return Qaul_Net_Messaging_FileMessage()
    }
    set {payload = .fileMessage(newValue)}
  }

  /// group message
  var groupMessage: Qaul_Net_Messaging_GroupMessage {
    get {
      if case .groupMessage(let v)? = payload {return v}
      return Qaul_Net_Messaging_GroupMessage()
    }
    set {payload = .groupMessage(newValue)}
  }

  /// rtc message
  var rtcMessage: Qaul_Net_Messaging_RtcMessage {
    get {
      if case .rtcMessage(let v)? = payload {return v}
      return Qaul_Net_Messaging_RtcMessage()
    }
    set {payload = .rtcMessage(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// payload
  enum OneOf_Payload: Equatable {
    /// chat message
    case chatMessage(Qaul_Net_Messaging_ChatMessage)
    /// file message
    case fileMessage(Qaul_Net_Messaging_FileMessage)
    /// group message
    case groupMessage(Qaul_Net_Messaging_GroupMessage)
    /// rtc message
    case rtcMessage(Qaul_Net_Messaging_RtcMessage)

  #if !swift(>=4.1)
    static func ==(lhs: Qaul_Net_Messaging_CommonMessage.OneOf_Payload, rhs: Qaul_Net_Messaging_CommonMessage.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.chatMessage, .chatMessage): return {
        guard case .chatMessage(let l) = lhs, case .chatMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fileMessage, .fileMessage): return {
        guard case .fileMessage(let l) = lhs, case .fileMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupMessage, .groupMessage): return {
        guard case .groupMessage(let l) = lhs, case .groupMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rtcMessage, .rtcMessage): return {
        guard case .rtcMessage(let l) = lhs, case .rtcMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// chat content
struct Qaul_Net_Messaging_ChatMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// content
  var content: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// file message
struct Qaul_Net_Messaging_FileMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// group message
struct Qaul_Net_Messaging_GroupMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// rtc message
struct Qaul_Net_Messaging_RtcMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DTN message
struct Qaul_Net_Messaging_Dtn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: Qaul_Net_Messaging_Dtn.OneOf_Message? = nil

  /// message container
  var container: Data {
    get {
      if case .container(let v)? = message {return v}
      return Data()
    }
    set {message = .container(newValue)}
  }

  /// message received response
  var response: Qaul_Net_Messaging_DtnResponse {
    get {
      if case .response(let v)? = message {return v}
      return Qaul_Net_Messaging_DtnResponse()
    }
    set {message = .response(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    /// message container
    case container(Data)
    /// message received response
    case response(Qaul_Net_Messaging_DtnResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Qaul_Net_Messaging_Dtn.OneOf_Message, rhs: Qaul_Net_Messaging_Dtn.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.container, .container): return {
        guard case .container(let l) = lhs, case .container(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.response, .response): return {
        guard case .response(let l) = lhs, case .response(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// DTN response
struct Qaul_Net_Messaging_DtnResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the type of the message
  var responseType: Qaul_Net_Messaging_DtnResponse.ResponseType = .accepted

  /// message signature reference
  var signature: Data = Data()

  /// reason of rejection
  var reason: Qaul_Net_Messaging_DtnResponse.Reason = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// the enum definition of the type
  enum ResponseType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// the message was accepted for storage
    case accepted // = 0

    /// the message was rejected
    case rejected // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .accepted
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .accepted
      case 1: self = .rejected
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .accepted: return 0
      case .rejected: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// the enum definition of the rejection reason
  enum Reason: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// none
    case none // = 0

    /// this user is not accepted
    case userNotAccepted // = 1

    /// overall quota reached
    case overallQuota // = 2

    /// user quota reached
    case userQuota // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .userNotAccepted
      case 2: self = .overallQuota
      case 3: self = .userQuota
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .userNotAccepted: return 1
      case .overallQuota: return 2
      case .userQuota: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Qaul_Net_Messaging_DtnResponse.ResponseType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Qaul_Net_Messaging_DtnResponse.ResponseType] = [
    .accepted,
    .rejected,
  ]
}

extension Qaul_Net_Messaging_DtnResponse.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Qaul_Net_Messaging_DtnResponse.Reason] = [
    .none,
    .userNotAccepted,
    .overallQuota,
    .userQuota,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "qaul.net.messaging"

extension Qaul_Net_Messaging_CryptoState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "HANDSHAKE"),
    2: .same(proto: "TRANSPORT"),
  ]
}

extension Qaul_Net_Messaging_Container: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Container"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .same(proto: "envelope"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._envelope) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 1)
    }
    try { if let v = self._envelope {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_Container, rhs: Qaul_Net_Messaging_Container) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs._envelope != rhs._envelope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Envelope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sender_id"),
    2: .standard(proto: "receiver_id"),
    3: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.senderID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.receiverID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.senderID.isEmpty {
      try visitor.visitSingularBytesField(value: self.senderID, fieldNumber: 1)
    }
    if !self.receiverID.isEmpty {
      try visitor.visitSingularBytesField(value: self.receiverID, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_Envelope, rhs: Qaul_Net_Messaging_Envelope) -> Bool {
    if lhs.senderID != rhs.senderID {return false}
    if lhs.receiverID != rhs.receiverID {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_EnvelopPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnvelopPayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encrypted"),
    2: .same(proto: "dtn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qaul_Net_Messaging_Encrypted?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .encrypted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .encrypted(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .dtn(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .encrypted?: try {
      guard case .encrypted(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .dtn?: try {
      guard case .dtn(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_EnvelopPayload, rhs: Qaul_Net_Messaging_EnvelopPayload) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_Encrypted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Encrypted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "session_id"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sessionID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .none {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if self.sessionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.sessionID, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_Encrypted, rhs: Qaul_Net_Messaging_Encrypted) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_Data, rhs: Qaul_Net_Messaging_Data) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_Messaging: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Messaging"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "confirmation_message"),
    2: .standard(proto: "dtn_response"),
    3: .standard(proto: "crypto_service"),
    4: .standard(proto: "rtc_stream_message"),
    5: .standard(proto: "group_invite_message"),
    6: .standard(proto: "common_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qaul_Net_Messaging_Confirmation?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .confirmationMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .confirmationMessage(v)
        }
      }()
      case 2: try {
        var v: Qaul_Net_Messaging_DtnResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .dtnResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .dtnResponse(v)
        }
      }()
      case 3: try {
        var v: Qaul_Net_Messaging_CryptoService?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .cryptoService(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .cryptoService(v)
        }
      }()
      case 4: try {
        var v: Qaul_Net_Messaging_RtcStreamMessage?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .rtcStreamMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .rtcStreamMessage(v)
        }
      }()
      case 5: try {
        var v: Qaul_Net_Messaging_GroupInviteMessage?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupInviteMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupInviteMessage(v)
        }
      }()
      case 6: try {
        var v: Qaul_Net_Messaging_CommonMessage?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .commonMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .commonMessage(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .confirmationMessage?: try {
      guard case .confirmationMessage(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .dtnResponse?: try {
      guard case .dtnResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cryptoService?: try {
      guard case .cryptoService(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .rtcStreamMessage?: try {
      guard case .rtcStreamMessage(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .groupInviteMessage?: try {
      guard case .groupInviteMessage(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .commonMessage?: try {
      guard case .commonMessage(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_Messaging, rhs: Qaul_Net_Messaging_Messaging) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_Confirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Confirmation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .standard(proto: "received_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.receivedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 1)
    }
    if self.receivedAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.receivedAt, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_Confirmation, rhs: Qaul_Net_Messaging_Confirmation) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.receivedAt != rhs.receivedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_CryptoService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CryptoService"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_CryptoService, rhs: Qaul_Net_Messaging_CryptoService) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_RtcStreamMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RtcStreamMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_RtcStreamMessage, rhs: Qaul_Net_Messaging_RtcStreamMessage) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_GroupInviteMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInviteMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_GroupInviteMessage, rhs: Qaul_Net_Messaging_GroupInviteMessage) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_CommonMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommonMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "group_id"),
    3: .standard(proto: "sent_at"),
    4: .standard(proto: "chat_message"),
    5: .standard(proto: "file_message"),
    6: .standard(proto: "group_message"),
    7: .standard(proto: "rtc_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.sentAt) }()
      case 4: try {
        var v: Qaul_Net_Messaging_ChatMessage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .chatMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .chatMessage(v)
        }
      }()
      case 5: try {
        var v: Qaul_Net_Messaging_FileMessage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .fileMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .fileMessage(v)
        }
      }()
      case 6: try {
        var v: Qaul_Net_Messaging_GroupMessage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .groupMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .groupMessage(v)
        }
      }()
      case 7: try {
        var v: Qaul_Net_Messaging_RtcMessage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .rtcMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .rtcMessage(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messageID.isEmpty {
      try visitor.visitSingularBytesField(value: self.messageID, fieldNumber: 1)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 2)
    }
    if self.sentAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.sentAt, fieldNumber: 3)
    }
    switch self.payload {
    case .chatMessage?: try {
      guard case .chatMessage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .fileMessage?: try {
      guard case .fileMessage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .groupMessage?: try {
      guard case .groupMessage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .rtcMessage?: try {
      guard case .rtcMessage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_CommonMessage, rhs: Qaul_Net_Messaging_CommonMessage) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.sentAt != rhs.sentAt {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_ChatMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChatMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_ChatMessage, rhs: Qaul_Net_Messaging_ChatMessage) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_FileMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_FileMessage, rhs: Qaul_Net_Messaging_FileMessage) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_GroupMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_GroupMessage, rhs: Qaul_Net_Messaging_GroupMessage) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_RtcMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RtcMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_RtcMessage, rhs: Qaul_Net_Messaging_RtcMessage) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_Dtn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Dtn"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "container"),
    2: .same(proto: "response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.message != nil {try decoder.handleConflictingOneOf()}
          self.message = .container(v)
        }
      }()
      case 2: try {
        var v: Qaul_Net_Messaging_DtnResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .response(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .response(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .container?: try {
      guard case .container(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .response?: try {
      guard case .response(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_Dtn, rhs: Qaul_Net_Messaging_Dtn) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_DtnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DtnResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_type"),
    2: .same(proto: "signature"),
    3: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.responseType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.responseType != .accepted {
      try visitor.visitSingularEnumField(value: self.responseType, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    if self.reason != .none {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Net_Messaging_DtnResponse, rhs: Qaul_Net_Messaging_DtnResponse) -> Bool {
    if lhs.responseType != rhs.responseType {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Net_Messaging_DtnResponse.ResponseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACCEPTED"),
    1: .same(proto: "REJECTED"),
  ]
}

extension Qaul_Net_Messaging_DtnResponse.Reason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "USER_NOT_ACCEPTED"),
    2: .same(proto: "OVERALL_QUOTA"),
    3: .same(proto: "USER_QUOTA"),
  ]
}
