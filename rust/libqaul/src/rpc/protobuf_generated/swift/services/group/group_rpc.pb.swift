// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/group/group_rpc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Group member state
enum Qaul_Rpc_Group_GroupMemberState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// invited
  case invited // = 0

  /// activated
  case activated // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .invited
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invited
    case 1: self = .activated
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .invited: return 0
    case .activated: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Qaul_Rpc_Group_GroupMemberState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Qaul_Rpc_Group_GroupMemberState] = [
    .invited,
    .activated,
  ]
}

#endif  // swift(>=4.2)

/// Group member role
enum Qaul_Rpc_Group_GroupMemberRole: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// user
  case user // = 0

  /// admin
  case admin // = 255
  case UNRECOGNIZED(Int)

  init() {
    self = .user
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .user
    case 255: self = .admin
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .user: return 0
    case .admin: return 255
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Qaul_Rpc_Group_GroupMemberRole: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Qaul_Rpc_Group_GroupMemberRole] = [
    .user,
    .admin,
  ]
}

#endif  // swift(>=4.2)

/// Group Status
///
/// Indicates the working status of a group.
enum Qaul_Rpc_Group_GroupStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Group is Active
  ///
  /// The group is in active state and we can post
  /// messages to this group.
  case active // = 0

  /// Invite Accepted
  ///
  /// We accepted the invitation to this group
  /// but we haven't received the updated group
  /// info from the group administrator yet.
  /// We therefore can't yet post messages into
  /// the group.
  case inviteAccepted // = 1

  /// The group was deactivated
  ///
  /// We either left the group or have been removed from the group
  /// by the group administrator.
  /// We therefore can't post messages into this group anymore.
  case deactivated // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .active
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .active
    case 1: self = .inviteAccepted
    case 2: self = .deactivated
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .active: return 0
    case .inviteAccepted: return 1
    case .deactivated: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Qaul_Rpc_Group_GroupStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Qaul_Rpc_Group_GroupStatus] = [
    .active,
    .inviteAccepted,
    .deactivated,
  ]
}

#endif  // swift(>=4.2)

/// Group service RPC message container
struct Qaul_Rpc_Group_Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message type
  var message: Qaul_Rpc_Group_Group.OneOf_Message? = nil

  /// group create request
  var groupCreateRequest: Qaul_Rpc_Group_GroupCreateRequest {
    get {
      if case .groupCreateRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupCreateRequest()
    }
    set {message = .groupCreateRequest(newValue)}
  }

  /// group create response
  var groupCreateResponse: Qaul_Rpc_Group_GroupCreateResponse {
    get {
      if case .groupCreateResponse(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupCreateResponse()
    }
    set {message = .groupCreateResponse(newValue)}
  }

  /// group rename request
  var groupRenameRequest: Qaul_Rpc_Group_GroupRenameRequest {
    get {
      if case .groupRenameRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupRenameRequest()
    }
    set {message = .groupRenameRequest(newValue)}
  }

  /// group rename response
  var groupRenameResponse: Qaul_Rpc_Group_GroupRenameResponse {
    get {
      if case .groupRenameResponse(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupRenameResponse()
    }
    set {message = .groupRenameResponse(newValue)}
  }

  /// group invite member request
  var groupInviteMemberRequest: Qaul_Rpc_Group_GroupInviteMemberRequest {
    get {
      if case .groupInviteMemberRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupInviteMemberRequest()
    }
    set {message = .groupInviteMemberRequest(newValue)}
  }

  /// group invite member response
  var groupInviteMemberResponse: Qaul_Rpc_Group_GroupInviteMemberResponse {
    get {
      if case .groupInviteMemberResponse(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupInviteMemberResponse()
    }
    set {message = .groupInviteMemberResponse(newValue)}
  }

  /// group remove member request
  var groupRemoveMemberRequest: Qaul_Rpc_Group_GroupRemoveMemberRequest {
    get {
      if case .groupRemoveMemberRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupRemoveMemberRequest()
    }
    set {message = .groupRemoveMemberRequest(newValue)}
  }

  /// group remove member response
  var groupRemoveMemberResponse: Qaul_Rpc_Group_GroupRemoveMemberResponse {
    get {
      if case .groupRemoveMemberResponse(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupRemoveMemberResponse()
    }
    set {message = .groupRemoveMemberResponse(newValue)}
  }

  /// group info request
  var groupInfoRequest: Qaul_Rpc_Group_GroupInfoRequest {
    get {
      if case .groupInfoRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupInfoRequest()
    }
    set {message = .groupInfoRequest(newValue)}
  }

  /// group info response
  var groupInfoResponse: Qaul_Rpc_Group_GroupInfo {
    get {
      if case .groupInfoResponse(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupInfo()
    }
    set {message = .groupInfoResponse(newValue)}
  }

  /// group reply invite request
  var groupReplyInviteRequest: Qaul_Rpc_Group_GroupReplyInviteRequest {
    get {
      if case .groupReplyInviteRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupReplyInviteRequest()
    }
    set {message = .groupReplyInviteRequest(newValue)}
  }

  /// group reply invite response
  var groupReplyInviteResponse: Qaul_Rpc_Group_GroupReplyInviteResponse {
    get {
      if case .groupReplyInviteResponse(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupReplyInviteResponse()
    }
    set {message = .groupReplyInviteResponse(newValue)}
  }

  /// group list request
  var groupListRequest: Qaul_Rpc_Group_GroupListRequest {
    get {
      if case .groupListRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupListRequest()
    }
    set {message = .groupListRequest(newValue)}
  }

  /// group list response
  var groupListResponse: Qaul_Rpc_Group_GroupListResponse {
    get {
      if case .groupListResponse(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupListResponse()
    }
    set {message = .groupListResponse(newValue)}
  }

  /// group invited
  var groupInvitedRequest: Qaul_Rpc_Group_GroupInvitedRequest {
    get {
      if case .groupInvitedRequest(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupInvitedRequest()
    }
    set {message = .groupInvitedRequest(newValue)}
  }

  /// group invited response
  var groupInvitedResponse: Qaul_Rpc_Group_GroupInvitedResponse {
    get {
      if case .groupInvitedResponse(let v)? = message {return v}
      return Qaul_Rpc_Group_GroupInvitedResponse()
    }
    set {message = .groupInvitedResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// message type
  enum OneOf_Message: Equatable {
    /// group create request
    case groupCreateRequest(Qaul_Rpc_Group_GroupCreateRequest)
    /// group create response
    case groupCreateResponse(Qaul_Rpc_Group_GroupCreateResponse)
    /// group rename request
    case groupRenameRequest(Qaul_Rpc_Group_GroupRenameRequest)
    /// group rename response
    case groupRenameResponse(Qaul_Rpc_Group_GroupRenameResponse)
    /// group invite member request
    case groupInviteMemberRequest(Qaul_Rpc_Group_GroupInviteMemberRequest)
    /// group invite member response
    case groupInviteMemberResponse(Qaul_Rpc_Group_GroupInviteMemberResponse)
    /// group remove member request
    case groupRemoveMemberRequest(Qaul_Rpc_Group_GroupRemoveMemberRequest)
    /// group remove member response
    case groupRemoveMemberResponse(Qaul_Rpc_Group_GroupRemoveMemberResponse)
    /// group info request
    case groupInfoRequest(Qaul_Rpc_Group_GroupInfoRequest)
    /// group info response
    case groupInfoResponse(Qaul_Rpc_Group_GroupInfo)
    /// group reply invite request
    case groupReplyInviteRequest(Qaul_Rpc_Group_GroupReplyInviteRequest)
    /// group reply invite response
    case groupReplyInviteResponse(Qaul_Rpc_Group_GroupReplyInviteResponse)
    /// group list request
    case groupListRequest(Qaul_Rpc_Group_GroupListRequest)
    /// group list response
    case groupListResponse(Qaul_Rpc_Group_GroupListResponse)
    /// group invited
    case groupInvitedRequest(Qaul_Rpc_Group_GroupInvitedRequest)
    /// group invited response
    case groupInvitedResponse(Qaul_Rpc_Group_GroupInvitedResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Qaul_Rpc_Group_Group.OneOf_Message, rhs: Qaul_Rpc_Group_Group.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.groupCreateRequest, .groupCreateRequest): return {
        guard case .groupCreateRequest(let l) = lhs, case .groupCreateRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupCreateResponse, .groupCreateResponse): return {
        guard case .groupCreateResponse(let l) = lhs, case .groupCreateResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupRenameRequest, .groupRenameRequest): return {
        guard case .groupRenameRequest(let l) = lhs, case .groupRenameRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupRenameResponse, .groupRenameResponse): return {
        guard case .groupRenameResponse(let l) = lhs, case .groupRenameResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupInviteMemberRequest, .groupInviteMemberRequest): return {
        guard case .groupInviteMemberRequest(let l) = lhs, case .groupInviteMemberRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupInviteMemberResponse, .groupInviteMemberResponse): return {
        guard case .groupInviteMemberResponse(let l) = lhs, case .groupInviteMemberResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupRemoveMemberRequest, .groupRemoveMemberRequest): return {
        guard case .groupRemoveMemberRequest(let l) = lhs, case .groupRemoveMemberRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupRemoveMemberResponse, .groupRemoveMemberResponse): return {
        guard case .groupRemoveMemberResponse(let l) = lhs, case .groupRemoveMemberResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupInfoRequest, .groupInfoRequest): return {
        guard case .groupInfoRequest(let l) = lhs, case .groupInfoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupInfoResponse, .groupInfoResponse): return {
        guard case .groupInfoResponse(let l) = lhs, case .groupInfoResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupReplyInviteRequest, .groupReplyInviteRequest): return {
        guard case .groupReplyInviteRequest(let l) = lhs, case .groupReplyInviteRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupReplyInviteResponse, .groupReplyInviteResponse): return {
        guard case .groupReplyInviteResponse(let l) = lhs, case .groupReplyInviteResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupListRequest, .groupListRequest): return {
        guard case .groupListRequest(let l) = lhs, case .groupListRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupListResponse, .groupListResponse): return {
        guard case .groupListResponse(let l) = lhs, case .groupListResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupInvitedRequest, .groupInvitedRequest): return {
        guard case .groupInvitedRequest(let l) = lhs, case .groupInvitedRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupInvitedResponse, .groupInvitedResponse): return {
        guard case .groupInvitedResponse(let l) = lhs, case .groupInvitedResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Group Result
struct Qaul_Rpc_Group_GroupResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// status
  ///
  /// true = success
  /// false = an error happened
  ///
  /// if the result is false, the message will
  /// contain the error message.
  var status: Bool = false

  /// message
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Create New Group
struct Qaul_Rpc_Group_GroupCreateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group name
  var groupName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group creating response
struct Qaul_Rpc_Group_GroupCreateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// result
  var result: Qaul_Rpc_Group_GroupResult {
    get {return _result ?? Qaul_Rpc_Group_GroupResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: Qaul_Rpc_Group_GroupResult? = nil
}

/// Group rename request
struct Qaul_Rpc_Group_GroupRenameRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// group name
  var groupName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group rename response
struct Qaul_Rpc_Group_GroupRenameResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// group name
  var groupName: String = String()

  /// result
  var result: Qaul_Rpc_Group_GroupResult {
    get {return _result ?? Qaul_Rpc_Group_GroupResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: Qaul_Rpc_Group_GroupResult? = nil
}

/// Invite member
struct Qaul_Rpc_Group_GroupInviteMemberRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// user id
  var userID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Invite member response
struct Qaul_Rpc_Group_GroupInviteMemberResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// user id
  var userID: Data = Data()

  /// result
  var result: Qaul_Rpc_Group_GroupResult {
    get {return _result ?? Qaul_Rpc_Group_GroupResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: Qaul_Rpc_Group_GroupResult? = nil
}

/// Reply Invite
struct Qaul_Rpc_Group_GroupReplyInviteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// accept
  var accept: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Reply Invite Response
struct Qaul_Rpc_Group_GroupReplyInviteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// result
  var result: Qaul_Rpc_Group_GroupResult {
    get {return _result ?? Qaul_Rpc_Group_GroupResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: Qaul_Rpc_Group_GroupResult? = nil
}

/// Remove member
struct Qaul_Rpc_Group_GroupRemoveMemberRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// user id
  var userID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Remove member
struct Qaul_Rpc_Group_GroupRemoveMemberResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// user id
  var userID: Data = Data()

  /// result
  var result: Qaul_Rpc_Group_GroupResult {
    get {return _result ?? Qaul_Rpc_Group_GroupResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: Qaul_Rpc_Group_GroupResult? = nil
}

/// Group info request
struct Qaul_Rpc_Group_GroupInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group member response
struct Qaul_Rpc_Group_GroupMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user id
  var userID: Data = Data()

  /// role
  var role: Qaul_Rpc_Group_GroupMemberRole = .user

  /// joined at
  var joinedAt: UInt64 = 0

  /// state
  var state: Qaul_Rpc_Group_GroupMemberState = .invited

  /// last message index
  var lastMessageIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group info response
struct Qaul_Rpc_Group_GroupInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group id
  var groupID: Data = Data()

  /// group name
  var groupName: String = String()

  /// created at
  var createdAt: UInt64 = 0

  /// group status
  var status: Qaul_Rpc_Group_GroupStatus = .active

  /// group revision number
  var revision: UInt32 = 0

  /// is direct chat
  var isDirectChat: Bool = false

  /// members
  var members: [Qaul_Rpc_Group_GroupMember] = []

  /// unread messages
  var unreadMessages: UInt32 = 0

  /// time when last message was sent
  var lastMessageAt: UInt64 = 0

  /// content type
  var lastMessage: Data = Data()

  /// sender of the last message
  var lastMessageSenderID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group list request
struct Qaul_Rpc_Group_GroupListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group info response
struct Qaul_Rpc_Group_GroupListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group list
  var groups: [Qaul_Rpc_Group_GroupInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Qaul_Rpc_Group_GroupInvited {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// sender id
  var senderID: Data = Data()

  /// received at
  var receivedAt: UInt64 = 0

  /// group info
  var group: Qaul_Rpc_Group_GroupInfo {
    get {return _group ?? Qaul_Rpc_Group_GroupInfo()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {self._group = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _group: Qaul_Rpc_Group_GroupInfo? = nil
}

/// Group list request
struct Qaul_Rpc_Group_GroupInvitedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group info response
struct Qaul_Rpc_Group_GroupInvitedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// invited list
  var invited: [Qaul_Rpc_Group_GroupInvited] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "qaul.rpc.group"

extension Qaul_Rpc_Group_GroupMemberState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Invited"),
    1: .same(proto: "Activated"),
  ]
}

extension Qaul_Rpc_Group_GroupMemberRole: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "User"),
    255: .same(proto: "Admin"),
  ]
}

extension Qaul_Rpc_Group_GroupStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTIVE"),
    1: .same(proto: "INVITE_ACCEPTED"),
    2: .same(proto: "DEACTIVATED"),
  ]
}

extension Qaul_Rpc_Group_Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_create_request"),
    2: .standard(proto: "group_create_response"),
    3: .standard(proto: "group_rename_request"),
    4: .standard(proto: "group_rename_response"),
    5: .standard(proto: "group_invite_member_request"),
    6: .standard(proto: "group_invite_member_response"),
    7: .standard(proto: "group_remove_member_request"),
    8: .standard(proto: "group_remove_member_response"),
    9: .standard(proto: "group_info_request"),
    10: .standard(proto: "group_info_response"),
    11: .standard(proto: "group_reply_invite_request"),
    12: .standard(proto: "group_reply_invite_response"),
    13: .standard(proto: "group_list_request"),
    14: .standard(proto: "group_list_response"),
    15: .standard(proto: "group_invited_request"),
    16: .standard(proto: "group_invited_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qaul_Rpc_Group_GroupCreateRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupCreateRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupCreateRequest(v)
        }
      }()
      case 2: try {
        var v: Qaul_Rpc_Group_GroupCreateResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupCreateResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupCreateResponse(v)
        }
      }()
      case 3: try {
        var v: Qaul_Rpc_Group_GroupRenameRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupRenameRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupRenameRequest(v)
        }
      }()
      case 4: try {
        var v: Qaul_Rpc_Group_GroupRenameResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupRenameResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupRenameResponse(v)
        }
      }()
      case 5: try {
        var v: Qaul_Rpc_Group_GroupInviteMemberRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupInviteMemberRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupInviteMemberRequest(v)
        }
      }()
      case 6: try {
        var v: Qaul_Rpc_Group_GroupInviteMemberResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupInviteMemberResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupInviteMemberResponse(v)
        }
      }()
      case 7: try {
        var v: Qaul_Rpc_Group_GroupRemoveMemberRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupRemoveMemberRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupRemoveMemberRequest(v)
        }
      }()
      case 8: try {
        var v: Qaul_Rpc_Group_GroupRemoveMemberResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupRemoveMemberResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupRemoveMemberResponse(v)
        }
      }()
      case 9: try {
        var v: Qaul_Rpc_Group_GroupInfoRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupInfoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupInfoRequest(v)
        }
      }()
      case 10: try {
        var v: Qaul_Rpc_Group_GroupInfo?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupInfoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupInfoResponse(v)
        }
      }()
      case 11: try {
        var v: Qaul_Rpc_Group_GroupReplyInviteRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupReplyInviteRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupReplyInviteRequest(v)
        }
      }()
      case 12: try {
        var v: Qaul_Rpc_Group_GroupReplyInviteResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupReplyInviteResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupReplyInviteResponse(v)
        }
      }()
      case 13: try {
        var v: Qaul_Rpc_Group_GroupListRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupListRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupListRequest(v)
        }
      }()
      case 14: try {
        var v: Qaul_Rpc_Group_GroupListResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupListResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupListResponse(v)
        }
      }()
      case 15: try {
        var v: Qaul_Rpc_Group_GroupInvitedRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupInvitedRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupInvitedRequest(v)
        }
      }()
      case 16: try {
        var v: Qaul_Rpc_Group_GroupInvitedResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .groupInvitedResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .groupInvitedResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .groupCreateRequest?: try {
      guard case .groupCreateRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .groupCreateResponse?: try {
      guard case .groupCreateResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .groupRenameRequest?: try {
      guard case .groupRenameRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .groupRenameResponse?: try {
      guard case .groupRenameResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .groupInviteMemberRequest?: try {
      guard case .groupInviteMemberRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .groupInviteMemberResponse?: try {
      guard case .groupInviteMemberResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .groupRemoveMemberRequest?: try {
      guard case .groupRemoveMemberRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .groupRemoveMemberResponse?: try {
      guard case .groupRemoveMemberResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .groupInfoRequest?: try {
      guard case .groupInfoRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .groupInfoResponse?: try {
      guard case .groupInfoResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .groupReplyInviteRequest?: try {
      guard case .groupReplyInviteRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .groupReplyInviteResponse?: try {
      guard case .groupReplyInviteResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .groupListRequest?: try {
      guard case .groupListRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .groupListResponse?: try {
      guard case .groupListResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .groupInvitedRequest?: try {
      guard case .groupInvitedRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .groupInvitedResponse?: try {
      guard case .groupInvitedResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_Group, rhs: Qaul_Rpc_Group_Group) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != false {
      try visitor.visitSingularBoolField(value: self.status, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupResult, rhs: Qaul_Rpc_Group_GroupResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupCreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupCreateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupCreateRequest, rhs: Qaul_Rpc_Group_GroupCreateRequest) -> Bool {
    if lhs.groupName != rhs.groupName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupCreateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupCreateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupCreateResponse, rhs: Qaul_Rpc_Group_GroupCreateResponse) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupRenameRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupRenameRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "group_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupRenameRequest, rhs: Qaul_Rpc_Group_GroupRenameRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupRenameResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupRenameResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "group_name"),
    3: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 2)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupRenameResponse, rhs: Qaul_Rpc_Group_GroupRenameResponse) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupInviteMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInviteMemberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupInviteMemberRequest, rhs: Qaul_Rpc_Group_GroupInviteMemberRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupInviteMemberResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInviteMemberResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_id"),
    3: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 2)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupInviteMemberResponse, rhs: Qaul_Rpc_Group_GroupInviteMemberResponse) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupReplyInviteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupReplyInviteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    3: .same(proto: "accept"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.accept) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if self.accept != false {
      try visitor.visitSingularBoolField(value: self.accept, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupReplyInviteRequest, rhs: Qaul_Rpc_Group_GroupReplyInviteRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.accept != rhs.accept {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupReplyInviteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupReplyInviteResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    3: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupReplyInviteResponse, rhs: Qaul_Rpc_Group_GroupReplyInviteResponse) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupRemoveMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupRemoveMemberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupRemoveMemberRequest, rhs: Qaul_Rpc_Group_GroupRemoveMemberRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupRemoveMemberResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupRemoveMemberResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_id"),
    3: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 2)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupRemoveMemberResponse, rhs: Qaul_Rpc_Group_GroupRemoveMemberResponse) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupInfoRequest, rhs: Qaul_Rpc_Group_GroupInfoRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupMember"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "role"),
    3: .standard(proto: "joined_at"),
    4: .same(proto: "state"),
    5: .standard(proto: "last_message_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.joinedAt) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.lastMessageIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 1)
    }
    if self.role != .user {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 2)
    }
    if self.joinedAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.joinedAt, fieldNumber: 3)
    }
    if self.state != .invited {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if self.lastMessageIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastMessageIndex, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupMember, rhs: Qaul_Rpc_Group_GroupMember) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.joinedAt != rhs.joinedAt {return false}
    if lhs.state != rhs.state {return false}
    if lhs.lastMessageIndex != rhs.lastMessageIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "group_name"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "status"),
    5: .same(proto: "revision"),
    6: .standard(proto: "is_direct_chat"),
    7: .same(proto: "members"),
    8: .standard(proto: "unread_messages"),
    9: .standard(proto: "last_message_at"),
    10: .standard(proto: "last_message"),
    11: .standard(proto: "last_message_sender_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.revision) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isDirectChat) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.unreadMessages) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.lastMessageAt) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.lastMessage) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.lastMessageSenderID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 2)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 3)
    }
    if self.status != .active {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if self.revision != 0 {
      try visitor.visitSingularUInt32Field(value: self.revision, fieldNumber: 5)
    }
    if self.isDirectChat != false {
      try visitor.visitSingularBoolField(value: self.isDirectChat, fieldNumber: 6)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 7)
    }
    if self.unreadMessages != 0 {
      try visitor.visitSingularUInt32Field(value: self.unreadMessages, fieldNumber: 8)
    }
    if self.lastMessageAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastMessageAt, fieldNumber: 9)
    }
    if !self.lastMessage.isEmpty {
      try visitor.visitSingularBytesField(value: self.lastMessage, fieldNumber: 10)
    }
    if !self.lastMessageSenderID.isEmpty {
      try visitor.visitSingularBytesField(value: self.lastMessageSenderID, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupInfo, rhs: Qaul_Rpc_Group_GroupInfo) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.status != rhs.status {return false}
    if lhs.revision != rhs.revision {return false}
    if lhs.isDirectChat != rhs.isDirectChat {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unreadMessages != rhs.unreadMessages {return false}
    if lhs.lastMessageAt != rhs.lastMessageAt {return false}
    if lhs.lastMessage != rhs.lastMessage {return false}
    if lhs.lastMessageSenderID != rhs.lastMessageSenderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupListRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupListRequest, rhs: Qaul_Rpc_Group_GroupListRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupListResponse, rhs: Qaul_Rpc_Group_GroupListResponse) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupInvited: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInvited"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sender_id"),
    2: .standard(proto: "received_at"),
    3: .same(proto: "group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.senderID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.receivedAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.senderID.isEmpty {
      try visitor.visitSingularBytesField(value: self.senderID, fieldNumber: 1)
    }
    if self.receivedAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.receivedAt, fieldNumber: 2)
    }
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupInvited, rhs: Qaul_Rpc_Group_GroupInvited) -> Bool {
    if lhs.senderID != rhs.senderID {return false}
    if lhs.receivedAt != rhs.receivedAt {return false}
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupInvitedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInvitedRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupInvitedRequest, rhs: Qaul_Rpc_Group_GroupInvitedRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Group_GroupInvitedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInvitedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invited"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.invited) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invited.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invited, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Group_GroupInvitedResponse, rhs: Qaul_Rpc_Group_GroupInvitedResponse) -> Bool {
    if lhs.invited != rhs.invited {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
