// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/dtn/dtn_rpc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// DTN service RPC message container
struct Qaul_Rpc_Dtn_DTN {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message type
  var message: Qaul_Rpc_Dtn_DTN.OneOf_Message? = nil

  /// dtn state request
  var dtnStateRequest: Qaul_Rpc_Dtn_DtnStateRequest {
    get {
      if case .dtnStateRequest(let v)? = message {return v}
      return Qaul_Rpc_Dtn_DtnStateRequest()
    }
    set {message = .dtnStateRequest(newValue)}
  }

  /// dtn state response
  var dtnStateResponse: Qaul_Rpc_Dtn_DtnStateResponse {
    get {
      if case .dtnStateResponse(let v)? = message {return v}
      return Qaul_Rpc_Dtn_DtnStateResponse()
    }
    set {message = .dtnStateResponse(newValue)}
  }

  /// dtn config request
  var dtnConfigRequest: Qaul_Rpc_Dtn_DtnConfigRequest {
    get {
      if case .dtnConfigRequest(let v)? = message {return v}
      return Qaul_Rpc_Dtn_DtnConfigRequest()
    }
    set {message = .dtnConfigRequest(newValue)}
  }

  /// dtn config response
  var dtnConfigResponse: Qaul_Rpc_Dtn_DtnConfigResponse {
    get {
      if case .dtnConfigResponse(let v)? = message {return v}
      return Qaul_Rpc_Dtn_DtnConfigResponse()
    }
    set {message = .dtnConfigResponse(newValue)}
  }

  /// dtn add user request
  var dtnAddUserRequest: Qaul_Rpc_Dtn_DtnAddUserRequest {
    get {
      if case .dtnAddUserRequest(let v)? = message {return v}
      return Qaul_Rpc_Dtn_DtnAddUserRequest()
    }
    set {message = .dtnAddUserRequest(newValue)}
  }

  /// dtn add user response
  var dtnAddUserResponse: Qaul_Rpc_Dtn_DtnAddUserResponse {
    get {
      if case .dtnAddUserResponse(let v)? = message {return v}
      return Qaul_Rpc_Dtn_DtnAddUserResponse()
    }
    set {message = .dtnAddUserResponse(newValue)}
  }

  /// dtn remove user request
  var dtnRemoveUserRequest: Qaul_Rpc_Dtn_DtnRemoveUserRequest {
    get {
      if case .dtnRemoveUserRequest(let v)? = message {return v}
      return Qaul_Rpc_Dtn_DtnRemoveUserRequest()
    }
    set {message = .dtnRemoveUserRequest(newValue)}
  }

  /// dtn remove user response
  var dtnRemoveUserResponse: Qaul_Rpc_Dtn_DtnRemoveUserResponse {
    get {
      if case .dtnRemoveUserResponse(let v)? = message {return v}
      return Qaul_Rpc_Dtn_DtnRemoveUserResponse()
    }
    set {message = .dtnRemoveUserResponse(newValue)}
  }

  /// dtn set total size request
  var dtnSetTotalSizeRequest: Qaul_Rpc_Dtn_DtnSetTotalSizeRequest {
    get {
      if case .dtnSetTotalSizeRequest(let v)? = message {return v}
      return Qaul_Rpc_Dtn_DtnSetTotalSizeRequest()
    }
    set {message = .dtnSetTotalSizeRequest(newValue)}
  }

  /// dtn set total size response
  var dtnSetTotalSizeResponse: Qaul_Rpc_Dtn_DtnSetTotalSizeResponse {
    get {
      if case .dtnSetTotalSizeResponse(let v)? = message {return v}
      return Qaul_Rpc_Dtn_DtnSetTotalSizeResponse()
    }
    set {message = .dtnSetTotalSizeResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// message type
  enum OneOf_Message: Equatable {
    /// dtn state request
    case dtnStateRequest(Qaul_Rpc_Dtn_DtnStateRequest)
    /// dtn state response
    case dtnStateResponse(Qaul_Rpc_Dtn_DtnStateResponse)
    /// dtn config request
    case dtnConfigRequest(Qaul_Rpc_Dtn_DtnConfigRequest)
    /// dtn config response
    case dtnConfigResponse(Qaul_Rpc_Dtn_DtnConfigResponse)
    /// dtn add user request
    case dtnAddUserRequest(Qaul_Rpc_Dtn_DtnAddUserRequest)
    /// dtn add user response
    case dtnAddUserResponse(Qaul_Rpc_Dtn_DtnAddUserResponse)
    /// dtn remove user request
    case dtnRemoveUserRequest(Qaul_Rpc_Dtn_DtnRemoveUserRequest)
    /// dtn remove user response
    case dtnRemoveUserResponse(Qaul_Rpc_Dtn_DtnRemoveUserResponse)
    /// dtn set total size request
    case dtnSetTotalSizeRequest(Qaul_Rpc_Dtn_DtnSetTotalSizeRequest)
    /// dtn set total size response
    case dtnSetTotalSizeResponse(Qaul_Rpc_Dtn_DtnSetTotalSizeResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Qaul_Rpc_Dtn_DTN.OneOf_Message, rhs: Qaul_Rpc_Dtn_DTN.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dtnStateRequest, .dtnStateRequest): return {
        guard case .dtnStateRequest(let l) = lhs, case .dtnStateRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dtnStateResponse, .dtnStateResponse): return {
        guard case .dtnStateResponse(let l) = lhs, case .dtnStateResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dtnConfigRequest, .dtnConfigRequest): return {
        guard case .dtnConfigRequest(let l) = lhs, case .dtnConfigRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dtnConfigResponse, .dtnConfigResponse): return {
        guard case .dtnConfigResponse(let l) = lhs, case .dtnConfigResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dtnAddUserRequest, .dtnAddUserRequest): return {
        guard case .dtnAddUserRequest(let l) = lhs, case .dtnAddUserRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dtnAddUserResponse, .dtnAddUserResponse): return {
        guard case .dtnAddUserResponse(let l) = lhs, case .dtnAddUserResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dtnRemoveUserRequest, .dtnRemoveUserRequest): return {
        guard case .dtnRemoveUserRequest(let l) = lhs, case .dtnRemoveUserRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dtnRemoveUserResponse, .dtnRemoveUserResponse): return {
        guard case .dtnRemoveUserResponse(let l) = lhs, case .dtnRemoveUserResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dtnSetTotalSizeRequest, .dtnSetTotalSizeRequest): return {
        guard case .dtnSetTotalSizeRequest(let l) = lhs, case .dtnSetTotalSizeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dtnSetTotalSizeResponse, .dtnSetTotalSizeResponse): return {
        guard case .dtnSetTotalSizeResponse(let l) = lhs, case .dtnSetTotalSizeResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Dtn State Request
struct Qaul_Rpc_Dtn_DtnStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Dtn State Response
struct Qaul_Rpc_Dtn_DtnStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// used size
  var usedSize: UInt64 = 0

  /// dtn message count
  var dtnMessageCount: UInt32 = 0

  /// unconfirmed count
  var unconfirmedCount: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Dtn Config Request
struct Qaul_Rpc_Dtn_DtnConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Dtn Config Response
struct Qaul_Rpc_Dtn_DtnConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total_size
  var totalSize: UInt32 = 0

  /// users
  var users: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Dtn Add User Request
struct Qaul_Rpc_Dtn_DtnAddUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user id
  var userID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Dtn Add User Response
struct Qaul_Rpc_Dtn_DtnAddUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total_size
  var status: Bool = false

  /// users
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Dtn Remove User Request
struct Qaul_Rpc_Dtn_DtnRemoveUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user id
  var userID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Dtn Remove User Response
struct Qaul_Rpc_Dtn_DtnRemoveUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total_size
  var status: Bool = false

  /// users
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Dtn SetTotalSize Request
struct Qaul_Rpc_Dtn_DtnSetTotalSizeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total_size
  var totalSize: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Dtn Remove User Response
struct Qaul_Rpc_Dtn_DtnSetTotalSizeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total_size
  var status: Bool = false

  /// users
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "qaul.rpc.dtn"

extension Qaul_Rpc_Dtn_DTN: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DTN"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dtn_state_request"),
    2: .standard(proto: "dtn_state_response"),
    3: .standard(proto: "dtn_config_request"),
    4: .standard(proto: "dtn_config_response"),
    5: .standard(proto: "dtn_add_user_request"),
    6: .standard(proto: "dtn_add_user_response"),
    7: .standard(proto: "dtn_remove_user_request"),
    8: .standard(proto: "dtn_remove_user_response"),
    9: .standard(proto: "dtn_set_total_size_request"),
    10: .standard(proto: "dtn_set_total_size_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qaul_Rpc_Dtn_DtnStateRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .dtnStateRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .dtnStateRequest(v)
        }
      }()
      case 2: try {
        var v: Qaul_Rpc_Dtn_DtnStateResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .dtnStateResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .dtnStateResponse(v)
        }
      }()
      case 3: try {
        var v: Qaul_Rpc_Dtn_DtnConfigRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .dtnConfigRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .dtnConfigRequest(v)
        }
      }()
      case 4: try {
        var v: Qaul_Rpc_Dtn_DtnConfigResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .dtnConfigResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .dtnConfigResponse(v)
        }
      }()
      case 5: try {
        var v: Qaul_Rpc_Dtn_DtnAddUserRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .dtnAddUserRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .dtnAddUserRequest(v)
        }
      }()
      case 6: try {
        var v: Qaul_Rpc_Dtn_DtnAddUserResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .dtnAddUserResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .dtnAddUserResponse(v)
        }
      }()
      case 7: try {
        var v: Qaul_Rpc_Dtn_DtnRemoveUserRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .dtnRemoveUserRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .dtnRemoveUserRequest(v)
        }
      }()
      case 8: try {
        var v: Qaul_Rpc_Dtn_DtnRemoveUserResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .dtnRemoveUserResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .dtnRemoveUserResponse(v)
        }
      }()
      case 9: try {
        var v: Qaul_Rpc_Dtn_DtnSetTotalSizeRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .dtnSetTotalSizeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .dtnSetTotalSizeRequest(v)
        }
      }()
      case 10: try {
        var v: Qaul_Rpc_Dtn_DtnSetTotalSizeResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .dtnSetTotalSizeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .dtnSetTotalSizeResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .dtnStateRequest?: try {
      guard case .dtnStateRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .dtnStateResponse?: try {
      guard case .dtnStateResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .dtnConfigRequest?: try {
      guard case .dtnConfigRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .dtnConfigResponse?: try {
      guard case .dtnConfigResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .dtnAddUserRequest?: try {
      guard case .dtnAddUserRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .dtnAddUserResponse?: try {
      guard case .dtnAddUserResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .dtnRemoveUserRequest?: try {
      guard case .dtnRemoveUserRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .dtnRemoveUserResponse?: try {
      guard case .dtnRemoveUserResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .dtnSetTotalSizeRequest?: try {
      guard case .dtnSetTotalSizeRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .dtnSetTotalSizeResponse?: try {
      guard case .dtnSetTotalSizeResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Dtn_DTN, rhs: Qaul_Rpc_Dtn_DTN) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Dtn_DtnStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DtnStateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Dtn_DtnStateRequest, rhs: Qaul_Rpc_Dtn_DtnStateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Dtn_DtnStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DtnStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "used_size"),
    2: .standard(proto: "dtn_message_count"),
    3: .standard(proto: "unconfirmed_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.usedSize) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.dtnMessageCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.unconfirmedCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.usedSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.usedSize, fieldNumber: 1)
    }
    if self.dtnMessageCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.dtnMessageCount, fieldNumber: 2)
    }
    if self.unconfirmedCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.unconfirmedCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Dtn_DtnStateResponse, rhs: Qaul_Rpc_Dtn_DtnStateResponse) -> Bool {
    if lhs.usedSize != rhs.usedSize {return false}
    if lhs.dtnMessageCount != rhs.dtnMessageCount {return false}
    if lhs.unconfirmedCount != rhs.unconfirmedCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Dtn_DtnConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DtnConfigRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Dtn_DtnConfigRequest, rhs: Qaul_Rpc_Dtn_DtnConfigRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Dtn_DtnConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DtnConfigResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_size"),
    2: .same(proto: "users"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.totalSize) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.users) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 1)
    }
    if !self.users.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.users, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Dtn_DtnConfigResponse, rhs: Qaul_Rpc_Dtn_DtnConfigResponse) -> Bool {
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Dtn_DtnAddUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DtnAddUserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Dtn_DtnAddUserRequest, rhs: Qaul_Rpc_Dtn_DtnAddUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Dtn_DtnAddUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DtnAddUserResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != false {
      try visitor.visitSingularBoolField(value: self.status, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Dtn_DtnAddUserResponse, rhs: Qaul_Rpc_Dtn_DtnAddUserResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Dtn_DtnRemoveUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DtnRemoveUserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Dtn_DtnRemoveUserRequest, rhs: Qaul_Rpc_Dtn_DtnRemoveUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Dtn_DtnRemoveUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DtnRemoveUserResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != false {
      try visitor.visitSingularBoolField(value: self.status, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Dtn_DtnRemoveUserResponse, rhs: Qaul_Rpc_Dtn_DtnRemoveUserResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Dtn_DtnSetTotalSizeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DtnSetTotalSizeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Dtn_DtnSetTotalSizeRequest, rhs: Qaul_Rpc_Dtn_DtnSetTotalSizeRequest) -> Bool {
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Rpc_Dtn_DtnSetTotalSizeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DtnSetTotalSizeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != false {
      try visitor.visitSingularBoolField(value: self.status, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Rpc_Dtn_DtnSetTotalSizeResponse, rhs: Qaul_Rpc_Dtn_DtnSetTotalSizeResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
