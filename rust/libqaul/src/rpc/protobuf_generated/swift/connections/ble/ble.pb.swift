// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: connections/ble/ble.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// qaul system communication with BLE module

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// power settings
/// 
/// These power settings relate to the android
/// power modes.
enum Qaul_Sys_Ble_BlePowerSetting: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// use power saving option
  ///
  /// this option will miss a lot of incoming messages,
  /// as the processor is often sleeping
  case lowPower // = 0

  /// use a compromise between power
  /// saving and reactivity
  case balanced // = 1

  /// always listen
  ///
  /// this option uses the most battery power
  case lowLatency // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .lowPower
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .lowPower
    case 1: self = .balanced
    case 2: self = .lowLatency
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .lowPower: return 0
    case .balanced: return 1
    case .lowLatency: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Qaul_Sys_Ble_BlePowerSetting: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Qaul_Sys_Ble_BlePowerSetting] = [
    .lowPower,
    .balanced,
    .lowLatency,
  ]
}

#endif  // swift(>=4.2)

/// BLE Error Reasons
///
/// TODO: this list needs to be completed
///       if none of the reasons apply, use 
///       UNKNOWN_ERROR
enum Qaul_Sys_Ble_BleError: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// undefined error
  ///
  /// use this when no other reason applies
  case unknownError // = 0

  /// the rights to use BLE were
  /// not provided by the user
  case rightsMissing // = 1

  /// there was a module timeout
  case timeout // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownError
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownError
    case 1: self = .rightsMissing
    case 2: self = .timeout
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownError: return 0
    case .rightsMissing: return 1
    case .timeout: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Qaul_Sys_Ble_BleError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Qaul_Sys_Ble_BleError] = [
    .unknownError,
    .rightsMissing,
    .timeout,
  ]
}

#endif  // swift(>=4.2)

/// BLE system communication message
struct Qaul_Sys_Ble_Ble {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message type
  var message: Qaul_Sys_Ble_Ble.OneOf_Message? = nil

  /// device information request
  var infoRequest: Qaul_Sys_Ble_BleInfoRequest {
    get {
      if case .infoRequest(let v)? = message {return v}
      return Qaul_Sys_Ble_BleInfoRequest()
    }
    set {message = .infoRequest(newValue)}
  }

  /// device information response
  var infoResponse: Qaul_Sys_Ble_BleInfoResponse {
    get {
      if case .infoResponse(let v)? = message {return v}
      return Qaul_Sys_Ble_BleInfoResponse()
    }
    set {message = .infoResponse(newValue)}
  }

  /// start device request
  var startRequest: Qaul_Sys_Ble_BleStartRequest {
    get {
      if case .startRequest(let v)? = message {return v}
      return Qaul_Sys_Ble_BleStartRequest()
    }
    set {message = .startRequest(newValue)}
  }

  /// start device result
  var startResult: Qaul_Sys_Ble_BleStartResult {
    get {
      if case .startResult(let v)? = message {return v}
      return Qaul_Sys_Ble_BleStartResult()
    }
    set {message = .startResult(newValue)}
  }

  /// stop device request
  var stopRequest: Qaul_Sys_Ble_BleStopRequest {
    get {
      if case .stopRequest(let v)? = message {return v}
      return Qaul_Sys_Ble_BleStopRequest()
    }
    set {message = .stopRequest(newValue)}
  }

  /// stop device result
  var stopResult: Qaul_Sys_Ble_BleStopResult {
    get {
      if case .stopResult(let v)? = message {return v}
      return Qaul_Sys_Ble_BleStopResult()
    }
    set {message = .stopResult(newValue)}
  }

  /// device discovered
  var deviceDiscovered: Qaul_Sys_Ble_BleDeviceDiscovered {
    get {
      if case .deviceDiscovered(let v)? = message {return v}
      return Qaul_Sys_Ble_BleDeviceDiscovered()
    }
    set {message = .deviceDiscovered(newValue)}
  }

  /// device became unavailable
  var deviceUnavailable: Qaul_Sys_Ble_BleDeviceUnavailable {
    get {
      if case .deviceUnavailable(let v)? = message {return v}
      return Qaul_Sys_Ble_BleDeviceUnavailable()
    }
    set {message = .deviceUnavailable(newValue)}
  }

  /// send a direct message
  var directSend: Qaul_Sys_Ble_BleDirectSend {
    get {
      if case .directSend(let v)? = message {return v}
      return Qaul_Sys_Ble_BleDirectSend()
    }
    set {message = .directSend(newValue)}
  }

  /// direct message send result
  var directSendResult: Qaul_Sys_Ble_BleDirectSendResult {
    get {
      if case .directSendResult(let v)? = message {return v}
      return Qaul_Sys_Ble_BleDirectSendResult()
    }
    set {message = .directSendResult(newValue)}
  }

  /// direct message received
  var directReceived: Qaul_Sys_Ble_BleDirectReceived {
    get {
      if case .directReceived(let v)? = message {return v}
      return Qaul_Sys_Ble_BleDirectReceived()
    }
    set {message = .directReceived(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// message type
  enum OneOf_Message: Equatable {
    /// device information request
    case infoRequest(Qaul_Sys_Ble_BleInfoRequest)
    /// device information response
    case infoResponse(Qaul_Sys_Ble_BleInfoResponse)
    /// start device request
    case startRequest(Qaul_Sys_Ble_BleStartRequest)
    /// start device result
    case startResult(Qaul_Sys_Ble_BleStartResult)
    /// stop device request
    case stopRequest(Qaul_Sys_Ble_BleStopRequest)
    /// stop device result
    case stopResult(Qaul_Sys_Ble_BleStopResult)
    /// device discovered
    case deviceDiscovered(Qaul_Sys_Ble_BleDeviceDiscovered)
    /// device became unavailable
    case deviceUnavailable(Qaul_Sys_Ble_BleDeviceUnavailable)
    /// send a direct message
    case directSend(Qaul_Sys_Ble_BleDirectSend)
    /// direct message send result
    case directSendResult(Qaul_Sys_Ble_BleDirectSendResult)
    /// direct message received
    case directReceived(Qaul_Sys_Ble_BleDirectReceived)

  #if !swift(>=4.1)
    static func ==(lhs: Qaul_Sys_Ble_Ble.OneOf_Message, rhs: Qaul_Sys_Ble_Ble.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.infoRequest, .infoRequest): return {
        guard case .infoRequest(let l) = lhs, case .infoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.infoResponse, .infoResponse): return {
        guard case .infoResponse(let l) = lhs, case .infoResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startRequest, .startRequest): return {
        guard case .startRequest(let l) = lhs, case .startRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startResult, .startResult): return {
        guard case .startResult(let l) = lhs, case .startResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stopRequest, .stopRequest): return {
        guard case .stopRequest(let l) = lhs, case .stopRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stopResult, .stopResult): return {
        guard case .stopResult(let l) = lhs, case .stopResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deviceDiscovered, .deviceDiscovered): return {
        guard case .deviceDiscovered(let l) = lhs, case .deviceDiscovered(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deviceUnavailable, .deviceUnavailable): return {
        guard case .deviceUnavailable(let l) = lhs, case .deviceUnavailable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.directSend, .directSend): return {
        guard case .directSend(let l) = lhs, case .directSend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.directSendResult, .directSendResult): return {
        guard case .directSendResult(let l) = lhs, case .directSendResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.directReceived, .directReceived): return {
        guard case .directReceived(let l) = lhs, case .directReceived(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// device information request message
struct Qaul_Sys_Ble_BleInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// device information response message
struct Qaul_Sys_Ble_BleInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// fill in a device information of the BLE device
  var device: Qaul_Sys_Ble_BleDeviceInfo {
    get {return _device ?? Qaul_Sys_Ble_BleDeviceInfo()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {self._device = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _device: Qaul_Sys_Ble_BleDeviceInfo? = nil
}

/// BLE device information
struct Qaul_Sys_Ble_BleDeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Check if Bluetooth / Bluetooth Low Energy is supported 
  ///
  /// Android: check if a bluetooth adapter is found
  var bleSupport: Bool = false

  /// Bluetooth device address
  /// 48 bit unique Bluetooth device addr
  /// e.g. 80:86:F2:08:C7:98
  /// 
  /// Android: BluetoothAdapter getAddress()
  /// https://developer.android.com/reference/kotlin/android/bluetooth/BluetoothAdapter#getAddress()
  var id: String = String()

  /// Get Bluetooth Name
  /// this is field is purely informative
  ///
  /// Android: BluetoothAdapter getName()
  /// https://developer.android.com/reference/kotlin/android/bluetooth/BluetoothAdapter#getName()
  var name: String = String()

  /// Bluetooth is enable / powered on
  ///
  /// Android: BluetoothAdapter isEnabled()
  /// https://developer.android.com/reference/kotlin/android/bluetooth/BluetoothAdapter#isEnabled() 
  var bluetoothOn: Bool = false

  /// Is extended advertisement supported?
  ///
  /// Android: BluetoothAdapter isLeExtendedAdvertisingSupported ()
  /// https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#isLeExtendedAdvertisingSupported()
  var advExtended: Bool = false

  /// what is the maximal amount of bytes sendable via advertising?
  ///
  /// Android: BluetoothAdapter getLeMaximumAdvertisingDataLength() 
  /// https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#getLeMaximumAdvertisingDataLength()
  var advExtendedBytes: UInt32 = 0

  /// Is 2M phy supported?
  ///
  /// Android: BluetoothAdapter isLe2MPhySupported()
  /// https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#isLe2MPhySupported()
  var le2M: Bool = false

  /// is extended advertising supported in coded
  /// mode? (For long distance connections)
  ///
  /// Android: BluetoothAdapter isLeCodedPhySupported()
  /// https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#isLeCodedPhySupported()
  var leCoded: Bool = false

  /// is LE audio supported?
  ///
  /// This is the most recent BLE feature, supported on:
  ///
  /// * android 12 and above
  /// * linux ?
  /// * ios ?
  /// * macos ?
  /// * windows ?
  ///
  /// Android: AndroidAdapter isLeAudioSupported()
  /// https://developer.android.com/reference/kotlin/android/bluetooth/BluetoothAdapter#isLeAudioSupported()
  var leAudio: Bool = false

  /// is periodic advertisment supported?
  ///
  /// Android: BluetoothAdapter isLePeriodicAdvertisingSupported()
  /// https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#isLePeriodicAdvertisingSupported()
  var lePeriodicAdvSupport: Bool = false

  /// Is multi advertisement supported?
  ///
  /// When multi advertisement is supported one can have different
  /// advertisement types parallely. Each advertisement has a 
  /// different device address.
  /// For scanning devices it looks, as if multiple devices devices
  /// would advertise themselves.
  /// This is helpful to support several incompatible advertisement
  /// modes at the same time.
  ///
  /// Android: BluetoothAdapter isMultipleAdvertisementSupported()
  /// https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#isMultipleAdvertisementSupported()
  var leMultipleAdvSupport: Bool = false

  /// Android Specific: is Offloaded Filtering Supported?
  ///
  /// Android: BluetoothAdapter isOffloadedFilteringSupported()
  var offloadFilterSupport: Bool = false

  /// Android Specific: is Offloaded Scan Batching Supported?
  ///
  /// Android: BluetoothAdapter isOffloadedScanBatchingSupported()
  /// https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#isOffloadedScanBatchingSupported()
  var offloadScanBatchingSupport: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Start Device
///
/// the module will try to start the device, power it up,
/// get all rights, configure it for qaul, and
/// send & receive advertising messages
struct Qaul_Sys_Ble_BleStartRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// qaul ID
  ///
  /// The small 16 byte qaul id
  /// to be used to identify this node
  var qaulID: Data = Data()

  /// power settings 
  var powerSetting: Qaul_Sys_Ble_BlePowerSetting = .lowPower

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Start device result message
///
/// Feedback from the 
struct Qaul_Sys_Ble_BleStartResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// whether the device was successfully started
  var success: Bool = false

  /// error reason
  var errorReason: Qaul_Sys_Ble_BleError = .unknownError

  /// error message
  var errorMessage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Stop Bluetooth Device
struct Qaul_Sys_Ble_BleStopRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Stop Result
///
/// Feedback of the stop request
struct Qaul_Sys_Ble_BleStopResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// whether the device was successfully stopped
  var success: Bool = false

  /// error reason
  var errorReason: Qaul_Sys_Ble_BleError = .unknownError

  /// error message
  var errorMessage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Device Discovered
///
/// A new device has been discovered.
struct Qaul_Sys_Ble_BleDeviceDiscovered {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// qaul id of the device
  var qaulID: Data = Data()

  /// the received signal strength of this device
  var rssi: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Device Unavailable
///
/// A formerly discovered device has become 
/// unavailable. No messages can be sent to it.
struct Qaul_Sys_Ble_BleDeviceUnavailable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// qaul id of the device that
  /// became unavailable
  var qaulID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// send a direct message
struct Qaul_Sys_Ble_BleDirectSend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message id (as a reference for the result message)
  var messageID: Data = Data()

  /// qaul id of the device to send it to
  var receiverID: Data = Data()

  /// qaul id of the sending device
  var senderID: Data = Data()

  /// data to be sent
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// result after sending the direct message
struct Qaul_Sys_Ble_BleDirectSendResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message id
  var id: Data = Data()

  /// result after sending the message
  var success: Bool = false

  /// error messages
  var errorMessage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// direct message received message
struct Qaul_Sys_Ble_BleDirectReceived {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// qaul id of the sending device
  var from: Data = Data()

  /// the data received
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "qaul.sys.ble"

extension Qaul_Sys_Ble_BlePowerSetting: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "low_power"),
    1: .same(proto: "balanced"),
    2: .same(proto: "low_latency"),
  ]
}

extension Qaul_Sys_Ble_BleError: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ERROR"),
    1: .same(proto: "RIGHTS_MISSING"),
    2: .same(proto: "TIMEOUT"),
  ]
}

extension Qaul_Sys_Ble_Ble: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ble"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "info_request"),
    2: .standard(proto: "info_response"),
    3: .standard(proto: "start_request"),
    4: .standard(proto: "start_result"),
    5: .standard(proto: "stop_request"),
    6: .standard(proto: "stop_result"),
    7: .standard(proto: "device_discovered"),
    8: .standard(proto: "device_unavailable"),
    9: .standard(proto: "direct_send"),
    10: .standard(proto: "direct_send_result"),
    11: .standard(proto: "direct_received"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qaul_Sys_Ble_BleInfoRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .infoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .infoRequest(v)
        }
      }()
      case 2: try {
        var v: Qaul_Sys_Ble_BleInfoResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .infoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .infoResponse(v)
        }
      }()
      case 3: try {
        var v: Qaul_Sys_Ble_BleStartRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .startRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .startRequest(v)
        }
      }()
      case 4: try {
        var v: Qaul_Sys_Ble_BleStartResult?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .startResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .startResult(v)
        }
      }()
      case 5: try {
        var v: Qaul_Sys_Ble_BleStopRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .stopRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .stopRequest(v)
        }
      }()
      case 6: try {
        var v: Qaul_Sys_Ble_BleStopResult?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .stopResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .stopResult(v)
        }
      }()
      case 7: try {
        var v: Qaul_Sys_Ble_BleDeviceDiscovered?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .deviceDiscovered(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .deviceDiscovered(v)
        }
      }()
      case 8: try {
        var v: Qaul_Sys_Ble_BleDeviceUnavailable?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .deviceUnavailable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .deviceUnavailable(v)
        }
      }()
      case 9: try {
        var v: Qaul_Sys_Ble_BleDirectSend?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .directSend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .directSend(v)
        }
      }()
      case 10: try {
        var v: Qaul_Sys_Ble_BleDirectSendResult?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .directSendResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .directSendResult(v)
        }
      }()
      case 11: try {
        var v: Qaul_Sys_Ble_BleDirectReceived?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .directReceived(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .directReceived(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .infoRequest?: try {
      guard case .infoRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .infoResponse?: try {
      guard case .infoResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .startRequest?: try {
      guard case .startRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .startResult?: try {
      guard case .startResult(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .stopRequest?: try {
      guard case .stopRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .stopResult?: try {
      guard case .stopResult(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .deviceDiscovered?: try {
      guard case .deviceDiscovered(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .deviceUnavailable?: try {
      guard case .deviceUnavailable(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .directSend?: try {
      guard case .directSend(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .directSendResult?: try {
      guard case .directSendResult(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .directReceived?: try {
      guard case .directReceived(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_Ble, rhs: Qaul_Sys_Ble_Ble) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleInfoRequest, rhs: Qaul_Sys_Ble_BleInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleInfoResponse, rhs: Qaul_Sys_Ble_BleInfoResponse) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleDeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleDeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ble_support"),
    2: .same(proto: "id"),
    3: .same(proto: "name"),
    4: .standard(proto: "bluetooth_on"),
    5: .standard(proto: "adv_extended"),
    6: .standard(proto: "adv_extended_bytes"),
    7: .standard(proto: "le_2m"),
    8: .standard(proto: "le_coded"),
    9: .standard(proto: "le_audio"),
    14: .standard(proto: "le_periodic_adv_support"),
    15: .standard(proto: "le_multiple_adv_support"),
    16: .standard(proto: "offload_filter_support"),
    17: .standard(proto: "offload_scan_batching_support"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.bleSupport) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.bluetoothOn) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.advExtended) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.advExtendedBytes) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.le2M) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.leCoded) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.leAudio) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.lePeriodicAdvSupport) }()
      case 15: try { try decoder.decodeSingularBoolField(value: &self.leMultipleAdvSupport) }()
      case 16: try { try decoder.decodeSingularBoolField(value: &self.offloadFilterSupport) }()
      case 17: try { try decoder.decodeSingularBoolField(value: &self.offloadScanBatchingSupport) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bleSupport != false {
      try visitor.visitSingularBoolField(value: self.bleSupport, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.bluetoothOn != false {
      try visitor.visitSingularBoolField(value: self.bluetoothOn, fieldNumber: 4)
    }
    if self.advExtended != false {
      try visitor.visitSingularBoolField(value: self.advExtended, fieldNumber: 5)
    }
    if self.advExtendedBytes != 0 {
      try visitor.visitSingularUInt32Field(value: self.advExtendedBytes, fieldNumber: 6)
    }
    if self.le2M != false {
      try visitor.visitSingularBoolField(value: self.le2M, fieldNumber: 7)
    }
    if self.leCoded != false {
      try visitor.visitSingularBoolField(value: self.leCoded, fieldNumber: 8)
    }
    if self.leAudio != false {
      try visitor.visitSingularBoolField(value: self.leAudio, fieldNumber: 9)
    }
    if self.lePeriodicAdvSupport != false {
      try visitor.visitSingularBoolField(value: self.lePeriodicAdvSupport, fieldNumber: 14)
    }
    if self.leMultipleAdvSupport != false {
      try visitor.visitSingularBoolField(value: self.leMultipleAdvSupport, fieldNumber: 15)
    }
    if self.offloadFilterSupport != false {
      try visitor.visitSingularBoolField(value: self.offloadFilterSupport, fieldNumber: 16)
    }
    if self.offloadScanBatchingSupport != false {
      try visitor.visitSingularBoolField(value: self.offloadScanBatchingSupport, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleDeviceInfo, rhs: Qaul_Sys_Ble_BleDeviceInfo) -> Bool {
    if lhs.bleSupport != rhs.bleSupport {return false}
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.bluetoothOn != rhs.bluetoothOn {return false}
    if lhs.advExtended != rhs.advExtended {return false}
    if lhs.advExtendedBytes != rhs.advExtendedBytes {return false}
    if lhs.le2M != rhs.le2M {return false}
    if lhs.leCoded != rhs.leCoded {return false}
    if lhs.leAudio != rhs.leAudio {return false}
    if lhs.lePeriodicAdvSupport != rhs.lePeriodicAdvSupport {return false}
    if lhs.leMultipleAdvSupport != rhs.leMultipleAdvSupport {return false}
    if lhs.offloadFilterSupport != rhs.offloadFilterSupport {return false}
    if lhs.offloadScanBatchingSupport != rhs.offloadScanBatchingSupport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleStartRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleStartRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "qaul_id"),
    2: .standard(proto: "power_setting"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.qaulID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.powerSetting) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.qaulID.isEmpty {
      try visitor.visitSingularBytesField(value: self.qaulID, fieldNumber: 1)
    }
    if self.powerSetting != .lowPower {
      try visitor.visitSingularEnumField(value: self.powerSetting, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleStartRequest, rhs: Qaul_Sys_Ble_BleStartRequest) -> Bool {
    if lhs.qaulID != rhs.qaulID {return false}
    if lhs.powerSetting != rhs.powerSetting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleStartResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleStartResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "error_reason"),
    3: .standard(proto: "error_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.errorReason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if self.errorReason != .unknownError {
      try visitor.visitSingularEnumField(value: self.errorReason, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleStartResult, rhs: Qaul_Sys_Ble_BleStartResult) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorReason != rhs.errorReason {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleStopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleStopRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleStopRequest, rhs: Qaul_Sys_Ble_BleStopRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleStopResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleStopResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "error_reason"),
    3: .standard(proto: "error_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.errorReason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if self.errorReason != .unknownError {
      try visitor.visitSingularEnumField(value: self.errorReason, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleStopResult, rhs: Qaul_Sys_Ble_BleStopResult) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorReason != rhs.errorReason {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleDeviceDiscovered: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleDeviceDiscovered"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "qaul_id"),
    2: .same(proto: "rssi"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.qaulID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.rssi) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.qaulID.isEmpty {
      try visitor.visitSingularBytesField(value: self.qaulID, fieldNumber: 1)
    }
    if self.rssi != 0 {
      try visitor.visitSingularInt32Field(value: self.rssi, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleDeviceDiscovered, rhs: Qaul_Sys_Ble_BleDeviceDiscovered) -> Bool {
    if lhs.qaulID != rhs.qaulID {return false}
    if lhs.rssi != rhs.rssi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleDeviceUnavailable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleDeviceUnavailable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "qaul_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.qaulID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.qaulID.isEmpty {
      try visitor.visitSingularBytesField(value: self.qaulID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleDeviceUnavailable, rhs: Qaul_Sys_Ble_BleDeviceUnavailable) -> Bool {
    if lhs.qaulID != rhs.qaulID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleDirectSend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleDirectSend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "receiver_id"),
    3: .standard(proto: "sender_id"),
    4: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.receiverID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.senderID) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularBytesField(value: self.messageID, fieldNumber: 1)
    }
    if !self.receiverID.isEmpty {
      try visitor.visitSingularBytesField(value: self.receiverID, fieldNumber: 2)
    }
    if !self.senderID.isEmpty {
      try visitor.visitSingularBytesField(value: self.senderID, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleDirectSend, rhs: Qaul_Sys_Ble_BleDirectSend) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.receiverID != rhs.receiverID {return false}
    if lhs.senderID != rhs.senderID {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleDirectSendResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleDirectSendResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "success"),
    3: .standard(proto: "error_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleDirectSendResult, rhs: Qaul_Sys_Ble_BleDirectSendResult) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleDirectReceived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleDirectReceived"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    4: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.from) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleDirectReceived, rhs: Qaul_Sys_Ble_BleDirectReceived) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
