// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: connections/ble/manager/ble.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// qaul system communication with BLE module

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// enum to describe how to send a message
enum Qaul_Sys_Ble_BleMode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// use legacy advertising mode (only 31 Byte payload)
  case legacy // = 0

  /// 1m phy
  case le1M // = 1

  /// 2m phy
  case le2M // = 2

  /// LE coded, which only half the speed
  case coded2 // = 3

  /// LE coded, which is 8 times slower
  case coded8 // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .legacy
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .legacy
    case 1: self = .le1M
    case 2: self = .le2M
    case 3: self = .coded2
    case 4: self = .coded8
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .legacy: return 0
    case .le1M: return 1
    case .le2M: return 2
    case .coded2: return 3
    case .coded8: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Qaul_Sys_Ble_BleMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Qaul_Sys_Ble_BleMode] = [
    .legacy,
    .le1M,
    .le2M,
    .coded2,
    .coded8,
  ]
}

#endif  // swift(>=4.2)

/// BLE system communication message
struct Qaul_Sys_Ble_Ble {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message type
  var message: Qaul_Sys_Ble_Ble.OneOf_Message? = nil

  /// device information request
  var infoRequest: Qaul_Sys_Ble_BleInfoRequest {
    get {
      if case .infoRequest(let v)? = message {return v}
      return Qaul_Sys_Ble_BleInfoRequest()
    }
    set {message = .infoRequest(newValue)}
  }

  /// device information response
  var infoResponse: Qaul_Sys_Ble_BleInfoResponse {
    get {
      if case .infoResponse(let v)? = message {return v}
      return Qaul_Sys_Ble_BleInfoResponse()
    }
    set {message = .infoResponse(newValue)}
  }

  /// start device request
  var startRequest: Qaul_Sys_Ble_BleStartRequest {
    get {
      if case .startRequest(let v)? = message {return v}
      return Qaul_Sys_Ble_BleStartRequest()
    }
    set {message = .startRequest(newValue)}
  }

  /// start device result
  var startResult: Qaul_Sys_Ble_BleStartResult {
    get {
      if case .startResult(let v)? = message {return v}
      return Qaul_Sys_Ble_BleStartResult()
    }
    set {message = .startResult(newValue)}
  }

  /// advertising set message content
  var advertisingSet: Qaul_Sys_Ble_BleAdvertisingSet {
    get {
      if case .advertisingSet(let v)? = message {return v}
      return Qaul_Sys_Ble_BleAdvertisingSet()
    }
    set {message = .advertisingSet(newValue)}
  }

  /// send advertsing message
  var advertisingSend: Qaul_Sys_Ble_BleAdvertisingSend {
    get {
      if case .advertisingSend(let v)? = message {return v}
      return Qaul_Sys_Ble_BleAdvertisingSend()
    }
    set {message = .advertisingSend(newValue)}
  }

  /// advertising message received
  var advertisingReceived: Qaul_Sys_Ble_BleAdvertisingReceived {
    get {
      if case .advertisingReceived(let v)? = message {return v}
      return Qaul_Sys_Ble_BleAdvertisingReceived()
    }
    set {message = .advertisingReceived(newValue)}
  }

  /// send a direct message
  var directSend: Qaul_Sys_Ble_BleDirectSend {
    get {
      if case .directSend(let v)? = message {return v}
      return Qaul_Sys_Ble_BleDirectSend()
    }
    set {message = .directSend(newValue)}
  }

  /// direct message received
  var directReceived: Qaul_Sys_Ble_BleDirectReceived {
    get {
      if case .directReceived(let v)? = message {return v}
      return Qaul_Sys_Ble_BleDirectReceived()
    }
    set {message = .directReceived(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// message type
  enum OneOf_Message: Equatable {
    /// device information request
    case infoRequest(Qaul_Sys_Ble_BleInfoRequest)
    /// device information response
    case infoResponse(Qaul_Sys_Ble_BleInfoResponse)
    /// start device request
    case startRequest(Qaul_Sys_Ble_BleStartRequest)
    /// start device result
    case startResult(Qaul_Sys_Ble_BleStartResult)
    /// advertising set message content
    case advertisingSet(Qaul_Sys_Ble_BleAdvertisingSet)
    /// send advertsing message
    case advertisingSend(Qaul_Sys_Ble_BleAdvertisingSend)
    /// advertising message received
    case advertisingReceived(Qaul_Sys_Ble_BleAdvertisingReceived)
    /// send a direct message
    case directSend(Qaul_Sys_Ble_BleDirectSend)
    /// direct message received
    case directReceived(Qaul_Sys_Ble_BleDirectReceived)

  #if !swift(>=4.1)
    static func ==(lhs: Qaul_Sys_Ble_Ble.OneOf_Message, rhs: Qaul_Sys_Ble_Ble.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.infoRequest, .infoRequest): return {
        guard case .infoRequest(let l) = lhs, case .infoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.infoResponse, .infoResponse): return {
        guard case .infoResponse(let l) = lhs, case .infoResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startRequest, .startRequest): return {
        guard case .startRequest(let l) = lhs, case .startRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startResult, .startResult): return {
        guard case .startResult(let l) = lhs, case .startResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.advertisingSet, .advertisingSet): return {
        guard case .advertisingSet(let l) = lhs, case .advertisingSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.advertisingSend, .advertisingSend): return {
        guard case .advertisingSend(let l) = lhs, case .advertisingSend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.advertisingReceived, .advertisingReceived): return {
        guard case .advertisingReceived(let l) = lhs, case .advertisingReceived(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.directSend, .directSend): return {
        guard case .directSend(let l) = lhs, case .directSend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.directReceived, .directReceived): return {
        guard case .directReceived(let l) = lhs, case .directReceived(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// device information request message
struct Qaul_Sys_Ble_BleInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// device information response message
struct Qaul_Sys_Ble_BleInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// fill in a device information for each device on the system
  var device: [Qaul_Sys_Ble_BleDeviceInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BLE device information
struct Qaul_Sys_Ble_BleDeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Bluetooth device address
  /// 48 bit unique Bluetooth device addr
  /// e.g. 80:86:F2:08:C7:98
  var id: String = String()

  /// vendor name, device name, etc
  /// this is field is purely informative
  var name: String = String()

  /// device powered on
  var powered: Bool = false

  /// BLE advertising features supported
  /// This field informs us if the basic necessities for 
  /// qaul BLE requirements are supportorted by
  /// this device.
  /// These requirements are:
  /// * BLE device roles: central & peripheral
  /// * Send & receive BLE advertisements
  var bleSupport: Bool = false

  /// does it support the 251 byte advertisement messages?
  var adv251: Bool = false

  /// is extended advertising supported
  var advExtended: Bool = false

  /// what is the maximal amount of bytes sendable via advertising
  var advExtendedBytes: UInt32 = 0

  /// the following checks for BLE 5 features
  /// is extended advertising supported?
  var adv1M: Bool = false

  /// is extended advertising supported with 2M phy?
  var adv2M: Bool = false

  /// is extended advertising supported in coded
  /// mode? (For long distance connections)
  var advCoded: Bool = false

  /// is LE audio supported?
  /// this is the most recent feature, supported by
  /// android 12 and above
  /// linux ?
  /// ios ?
  /// macos ?
  /// windows ?
  var leAudio: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// start device request message
/// the module will try to start the device, power it up,
/// get all rights, configure it for qaul, and
/// send & receive advertising messages
struct Qaul_Sys_Ble_BleStartRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// start device result message
/// this is the feedback 
struct Qaul_Sys_Ble_BleStartResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// whether the start of the device was a success or not
  var success: Bool = false

  /// error message
  var errorMessage: String = String()

  /// error reasons
  var unknonwError: Bool = false

  /// rights not provided
  var noRights: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// advertising set message content
struct Qaul_Sys_Ble_BleAdvertisingSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// set data which can be used for interval data advertisement
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// send advertsing message
struct Qaul_Sys_Ble_BleAdvertisingSend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// advertising mode
  var mode: Qaul_Sys_Ble_BleMode = .legacy

  /// the data to be sent in the data field
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// advertising message received
struct Qaul_Sys_Ble_BleAdvertisingReceived {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the Bluetooth address of the device sending the advertisement
  var id: Data = Data()

  /// the received signal strength of this device
  var rssi: Int32 = 0

  /// the mode it was sent in
  var mode: Qaul_Sys_Ble_BleMode = .legacy

  /// the data part of the advertising message
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// send a direct message
struct Qaul_Sys_Ble_BleDirectSend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message id (as a reference for the result message)
  var id: Data = Data()

  /// bluetooth address of the device to send it to
  var to: Data = Data()

  /// sending mode
  var mode: Qaul_Sys_Ble_BleMode = .legacy

  /// data to be sent
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// result after sending the direct message
struct Qaul_Sys_Ble_BleDirectSendResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message id
  var id: Data = Data()

  /// result after sending the message
  var success: Bool = false

  /// error messages
  var errorMessage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// direct message received message
struct Qaul_Sys_Ble_BleDirectReceived {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// bluetooth address of the sending device
  var from: Data = Data()

  /// received signal strength of the sending device
  var rssi: Int32 = 0

  /// the mode this message was sent in
  var mode: Qaul_Sys_Ble_BleMode = .legacy

  /// the data received
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "qaul.sys.ble"

extension Qaul_Sys_Ble_BleMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "legacy"),
    1: .same(proto: "le_1m"),
    2: .same(proto: "le_2m"),
    3: .same(proto: "coded_2"),
    4: .same(proto: "coded_8"),
  ]
}

extension Qaul_Sys_Ble_Ble: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ble"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "info_request"),
    2: .standard(proto: "info_response"),
    3: .standard(proto: "start_request"),
    4: .standard(proto: "start_result"),
    5: .standard(proto: "advertising_set"),
    6: .standard(proto: "advertising_send"),
    7: .standard(proto: "advertising_received"),
    8: .standard(proto: "direct_send"),
    9: .standard(proto: "direct_received"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qaul_Sys_Ble_BleInfoRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .infoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .infoRequest(v)
        }
      }()
      case 2: try {
        var v: Qaul_Sys_Ble_BleInfoResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .infoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .infoResponse(v)
        }
      }()
      case 3: try {
        var v: Qaul_Sys_Ble_BleStartRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .startRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .startRequest(v)
        }
      }()
      case 4: try {
        var v: Qaul_Sys_Ble_BleStartResult?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .startResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .startResult(v)
        }
      }()
      case 5: try {
        var v: Qaul_Sys_Ble_BleAdvertisingSet?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .advertisingSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .advertisingSet(v)
        }
      }()
      case 6: try {
        var v: Qaul_Sys_Ble_BleAdvertisingSend?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .advertisingSend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .advertisingSend(v)
        }
      }()
      case 7: try {
        var v: Qaul_Sys_Ble_BleAdvertisingReceived?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .advertisingReceived(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .advertisingReceived(v)
        }
      }()
      case 8: try {
        var v: Qaul_Sys_Ble_BleDirectSend?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .directSend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .directSend(v)
        }
      }()
      case 9: try {
        var v: Qaul_Sys_Ble_BleDirectReceived?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .directReceived(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .directReceived(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .infoRequest?: try {
      guard case .infoRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .infoResponse?: try {
      guard case .infoResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .startRequest?: try {
      guard case .startRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .startResult?: try {
      guard case .startResult(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .advertisingSet?: try {
      guard case .advertisingSet(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .advertisingSend?: try {
      guard case .advertisingSend(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .advertisingReceived?: try {
      guard case .advertisingReceived(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .directSend?: try {
      guard case .directSend(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .directReceived?: try {
      guard case .directReceived(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_Ble, rhs: Qaul_Sys_Ble_Ble) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleInfoRequest, rhs: Qaul_Sys_Ble_BleInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.device) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.device.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.device, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleInfoResponse, rhs: Qaul_Sys_Ble_BleInfoResponse) -> Bool {
    if lhs.device != rhs.device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleDeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleDeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "powered"),
    4: .standard(proto: "ble_support"),
    7: .standard(proto: "adv_251"),
    8: .standard(proto: "adv_extended"),
    9: .standard(proto: "adv_extended_bytes"),
    10: .standard(proto: "adv_1m"),
    11: .standard(proto: "adv_2m"),
    12: .standard(proto: "adv_coded"),
    13: .standard(proto: "le_audio"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.powered) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.bleSupport) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.adv251) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.advExtended) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.advExtendedBytes) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.adv1M) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.adv2M) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.advCoded) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.leAudio) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.powered != false {
      try visitor.visitSingularBoolField(value: self.powered, fieldNumber: 3)
    }
    if self.bleSupport != false {
      try visitor.visitSingularBoolField(value: self.bleSupport, fieldNumber: 4)
    }
    if self.adv251 != false {
      try visitor.visitSingularBoolField(value: self.adv251, fieldNumber: 7)
    }
    if self.advExtended != false {
      try visitor.visitSingularBoolField(value: self.advExtended, fieldNumber: 8)
    }
    if self.advExtendedBytes != 0 {
      try visitor.visitSingularUInt32Field(value: self.advExtendedBytes, fieldNumber: 9)
    }
    if self.adv1M != false {
      try visitor.visitSingularBoolField(value: self.adv1M, fieldNumber: 10)
    }
    if self.adv2M != false {
      try visitor.visitSingularBoolField(value: self.adv2M, fieldNumber: 11)
    }
    if self.advCoded != false {
      try visitor.visitSingularBoolField(value: self.advCoded, fieldNumber: 12)
    }
    if self.leAudio != false {
      try visitor.visitSingularBoolField(value: self.leAudio, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleDeviceInfo, rhs: Qaul_Sys_Ble_BleDeviceInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.powered != rhs.powered {return false}
    if lhs.bleSupport != rhs.bleSupport {return false}
    if lhs.adv251 != rhs.adv251 {return false}
    if lhs.advExtended != rhs.advExtended {return false}
    if lhs.advExtendedBytes != rhs.advExtendedBytes {return false}
    if lhs.adv1M != rhs.adv1M {return false}
    if lhs.adv2M != rhs.adv2M {return false}
    if lhs.advCoded != rhs.advCoded {return false}
    if lhs.leAudio != rhs.leAudio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleStartRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleStartRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleStartRequest, rhs: Qaul_Sys_Ble_BleStartRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleStartResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleStartResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "error_message"),
    3: .standard(proto: "unknonw_error"),
    4: .standard(proto: "no_rights"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.unknonwError) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.noRights) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    if self.unknonwError != false {
      try visitor.visitSingularBoolField(value: self.unknonwError, fieldNumber: 3)
    }
    if self.noRights != false {
      try visitor.visitSingularBoolField(value: self.noRights, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleStartResult, rhs: Qaul_Sys_Ble_BleStartResult) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknonwError != rhs.unknonwError {return false}
    if lhs.noRights != rhs.noRights {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleAdvertisingSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleAdvertisingSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleAdvertisingSet, rhs: Qaul_Sys_Ble_BleAdvertisingSet) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleAdvertisingSend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleAdvertisingSend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .legacy {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleAdvertisingSend, rhs: Qaul_Sys_Ble_BleAdvertisingSend) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleAdvertisingReceived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleAdvertisingReceived"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "rssi"),
    3: .same(proto: "mode"),
    4: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.rssi) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if self.rssi != 0 {
      try visitor.visitSingularInt32Field(value: self.rssi, fieldNumber: 2)
    }
    if self.mode != .legacy {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleAdvertisingReceived, rhs: Qaul_Sys_Ble_BleAdvertisingReceived) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.rssi != rhs.rssi {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleDirectSend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleDirectSend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "to"),
    3: .same(proto: "mode"),
    4: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.to) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularBytesField(value: self.to, fieldNumber: 2)
    }
    if self.mode != .legacy {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleDirectSend, rhs: Qaul_Sys_Ble_BleDirectSend) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.to != rhs.to {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleDirectSendResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleDirectSendResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "success"),
    3: .standard(proto: "error_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleDirectSendResult, rhs: Qaul_Sys_Ble_BleDirectSendResult) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleDirectReceived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleDirectReceived"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "rssi"),
    3: .same(proto: "mode"),
    4: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.from) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.rssi) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if self.rssi != 0 {
      try visitor.visitSingularInt32Field(value: self.rssi, fieldNumber: 2)
    }
    if self.mode != .legacy {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleDirectReceived, rhs: Qaul_Sys_Ble_BleDirectReceived) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.rssi != rhs.rssi {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
