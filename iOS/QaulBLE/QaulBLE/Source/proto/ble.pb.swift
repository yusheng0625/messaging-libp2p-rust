// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ble.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// enum to describe how to send a message
enum Qaul_Sys_Ble_BleMode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///NEW ADDED
  case lowPower // = 0
  case balanced // = 1
  case lowLatency // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .lowPower
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .lowPower
    case 1: self = .balanced
    case 2: self = .lowLatency
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .lowPower: return 0
    case .balanced: return 1
    case .lowLatency: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Qaul_Sys_Ble_BleMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Qaul_Sys_Ble_BleMode] = [
    .lowPower,
    .balanced,
    .lowLatency,
  ]
}

#endif  // swift(>=4.2)

/// BLE system communication message
struct Qaul_Sys_Ble_Ble {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message type
  var message: Qaul_Sys_Ble_Ble.OneOf_Message? = nil

  /// device information request
  var infoRequest: Qaul_Sys_Ble_BleInfoRequest {
    get {
      if case .infoRequest(let v)? = message {return v}
      return Qaul_Sys_Ble_BleInfoRequest()
    }
    set {message = .infoRequest(newValue)}
  }

  /// device information response
  var infoResponse: Qaul_Sys_Ble_BleInfoResponse {
    get {
      if case .infoResponse(let v)? = message {return v}
      return Qaul_Sys_Ble_BleInfoResponse()
    }
    set {message = .infoResponse(newValue)}
  }

  /// start device request
  var startRequest: Qaul_Sys_Ble_BleStartRequest {
    get {
      if case .startRequest(let v)? = message {return v}
      return Qaul_Sys_Ble_BleStartRequest()
    }
    set {message = .startRequest(newValue)}
  }

  /// start device result
  var startResult: Qaul_Sys_Ble_BleStartResult {
    get {
      if case .startResult(let v)? = message {return v}
      return Qaul_Sys_Ble_BleStartResult()
    }
    set {message = .startResult(newValue)}
  }

  /// advertising set message content
  var advertisingSet: Qaul_Sys_Ble_BleAdvertisingSet {
    get {
      if case .advertisingSet(let v)? = message {return v}
      return Qaul_Sys_Ble_BleAdvertisingSet()
    }
    set {message = .advertisingSet(newValue)}
  }

  /// send advertsing message
  var advertisingSend: Qaul_Sys_Ble_BleAdvertisingSend {
    get {
      if case .advertisingSend(let v)? = message {return v}
      return Qaul_Sys_Ble_BleAdvertisingSend()
    }
    set {message = .advertisingSend(newValue)}
  }

  /// advertising message received
  var scanResult: Qaul_Sys_Ble_BleScanResult {
    get {
      if case .scanResult(let v)? = message {return v}
      return Qaul_Sys_Ble_BleScanResult()
    }
    set {message = .scanResult(newValue)}
  }

  /// send a direct message
  var directSend: Qaul_Sys_Ble_BleDirectSend {
    get {
      if case .directSend(let v)? = message {return v}
      return Qaul_Sys_Ble_BleDirectSend()
    }
    set {message = .directSend(newValue)}
  }

  /// send a direct message result
  var directSendResult: Qaul_Sys_Ble_BleDirectSendResult {
    get {
      if case .directSendResult(let v)? = message {return v}
      return Qaul_Sys_Ble_BleDirectSendResult()
    }
    set {message = .directSendResult(newValue)}
  }

  /// direct message received
  var directReceived: Qaul_Sys_Ble_BleDirectReceived {
    get {
      if case .directReceived(let v)? = message {return v}
      return Qaul_Sys_Ble_BleDirectReceived()
    }
    set {message = .directReceived(newValue)}
  }

  /// stop service request
  var stopRequest: Qaul_Sys_Ble_BleStopRequest {
    get {
      if case .stopRequest(let v)? = message {return v}
      return Qaul_Sys_Ble_BleStopRequest()
    }
    set {message = .stopRequest(newValue)}
  }

  /// stop service result
  var stopResult: Qaul_Sys_Ble_BleStopResult {
    get {
      if case .stopResult(let v)? = message {return v}
      return Qaul_Sys_Ble_BleStopResult()
    }
    set {message = .stopResult(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// message type
  enum OneOf_Message: Equatable {
    /// device information request
    case infoRequest(Qaul_Sys_Ble_BleInfoRequest)
    /// device information response
    case infoResponse(Qaul_Sys_Ble_BleInfoResponse)
    /// start device request
    case startRequest(Qaul_Sys_Ble_BleStartRequest)
    /// start device result
    case startResult(Qaul_Sys_Ble_BleStartResult)
    /// advertising set message content
    case advertisingSet(Qaul_Sys_Ble_BleAdvertisingSet)
    /// send advertsing message
    case advertisingSend(Qaul_Sys_Ble_BleAdvertisingSend)
    /// advertising message received
    case scanResult(Qaul_Sys_Ble_BleScanResult)
    /// send a direct message
    case directSend(Qaul_Sys_Ble_BleDirectSend)
    /// send a direct message result
    case directSendResult(Qaul_Sys_Ble_BleDirectSendResult)
    /// direct message received
    case directReceived(Qaul_Sys_Ble_BleDirectReceived)
    /// stop service request
    case stopRequest(Qaul_Sys_Ble_BleStopRequest)
    /// stop service result
    case stopResult(Qaul_Sys_Ble_BleStopResult)

  #if !swift(>=4.1)
    static func ==(lhs: Qaul_Sys_Ble_Ble.OneOf_Message, rhs: Qaul_Sys_Ble_Ble.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.infoRequest, .infoRequest): return {
        guard case .infoRequest(let l) = lhs, case .infoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.infoResponse, .infoResponse): return {
        guard case .infoResponse(let l) = lhs, case .infoResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startRequest, .startRequest): return {
        guard case .startRequest(let l) = lhs, case .startRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startResult, .startResult): return {
        guard case .startResult(let l) = lhs, case .startResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.advertisingSet, .advertisingSet): return {
        guard case .advertisingSet(let l) = lhs, case .advertisingSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.advertisingSend, .advertisingSend): return {
        guard case .advertisingSend(let l) = lhs, case .advertisingSend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scanResult, .scanResult): return {
        guard case .scanResult(let l) = lhs, case .scanResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.directSend, .directSend): return {
        guard case .directSend(let l) = lhs, case .directSend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.directSendResult, .directSendResult): return {
        guard case .directSendResult(let l) = lhs, case .directSendResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.directReceived, .directReceived): return {
        guard case .directReceived(let l) = lhs, case .directReceived(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stopRequest, .stopRequest): return {
        guard case .stopRequest(let l) = lhs, case .stopRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stopResult, .stopResult): return {
        guard case .stopResult(let l) = lhs, case .stopResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// device information request message
struct Qaul_Sys_Ble_BleInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// device information response message
struct Qaul_Sys_Ble_BleInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///  Edited by Vishal 26-11-2021:
  ///  Removed repeated keyword because Android will only one Device
  var device: Qaul_Sys_Ble_BleDeviceInfo {
    get {return _device ?? Qaul_Sys_Ble_BleDeviceInfo()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {self._device = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _device: Qaul_Sys_Ble_BleDeviceInfo? = nil
}

/// BLE device information
struct Qaul_Sys_Ble_BleDeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Bluetooth device address
  /// 48 bit unique Bluetooth device addr
  /// e.g. 80:86:F2:08:C7:98
  ///REMOVED: We can not find this
  ///    string id = 1;
  ///NEWLY ADDED: device location permission
  var locationPermission: Bool {
    get {return _storage._locationPermission}
    set {_uniqueStorage()._locationPermission = newValue}
  }

  ///NEWLY ADDED:  device location is on
  var locationOn: Bool {
    get {return _storage._locationOn}
    set {_uniqueStorage()._locationOn = newValue}
  }

  ///NEWLY ADDED:  device ble permission for Android 12 & above
  var blePermission: Bool {
    get {return _storage._blePermission}
    set {_uniqueStorage()._blePermission = newValue}
  }

  ///device powered on
  var bluetoothOn: Bool {
    get {return _storage._bluetoothOn}
    set {_uniqueStorage()._bluetoothOn = newValue}
  }

  ///NEWLY ADDED:  device android version
  var androidVersion: Int32 {
    get {return _storage._androidVersion}
    set {_uniqueStorage()._androidVersion = newValue}
  }

  /// vendor name, device name, etc
  /// this is field is purely informative
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// BLE advertising features supported
  /// This field informs us if the basic necessities for
  /// qaul BLE requirements are supported by
  /// this device.
  /// These requirements are:
  /// * BLE device roles: central & peripheral
  /// * Send & receive BLE advertisements
  var bleSupport: Bool {
    get {return _storage._bleSupport}
    set {_uniqueStorage()._bleSupport = newValue}
  }

  /// does it support the 251 byte advertisement messages?
  var adv251: Bool {
    get {return _storage._adv251}
    set {_uniqueStorage()._adv251 = newValue}
  }

  ///REMOVED:  is extended advertising supported same as adv_1m
  ///    bool adv_extended = 9;
  /// what is the maximal amount of bytes sendable via advertising
  var advExtendedBytes: UInt32 {
    get {return _storage._advExtendedBytes}
    set {_uniqueStorage()._advExtendedBytes = newValue}
  }

  /// the following checks for BLE 5 features
  /// is extended advertising supported?
  var adv1M: Bool {
    get {return _storage._adv1M}
    set {_uniqueStorage()._adv1M = newValue}
  }

  /// is extended advertising supported with 2M phy?
  var adv2M: Bool {
    get {return _storage._adv2M}
    set {_uniqueStorage()._adv2M = newValue}
  }

  /// is extended advertising supported in coded
  /// mode? (For long distance connections)
  var advCoded: Bool {
    get {return _storage._advCoded}
    set {_uniqueStorage()._advCoded = newValue}
  }

  /// is LE audio supported?
  /// this is the most recent feature, supported by
  /// android 12 and above
  /// linux ?
  /// ios ?
  /// macos ?
  /// windows ?
  var leAudio: Bool {
    get {return _storage._leAudio}
    set {_uniqueStorage()._leAudio = newValue}
  }

  ///NEWLY ADDED:  isLePeriodicAdvertisingSupported
  var lePeriodicAdvSupport: Bool {
    get {return _storage._lePeriodicAdvSupport}
    set {_uniqueStorage()._lePeriodicAdvSupport = newValue}
  }

  ///NEWLY ADDED:  isMultipleAdvertisementSupported
  var leMultipleAdvSupport: Bool {
    get {return _storage._leMultipleAdvSupport}
    set {_uniqueStorage()._leMultipleAdvSupport = newValue}
  }

  ///NEWLY ADDED:  isOffloadedFilteringSupported
  var offloadFilterSupport: Bool {
    get {return _storage._offloadFilterSupport}
    set {_uniqueStorage()._offloadFilterSupport = newValue}
  }

  ///NEWLY ADDED:  isOffloadedScanBatchingSupported
  var offloadScanBatchingSupport: Bool {
    get {return _storage._offloadScanBatchingSupport}
    set {_uniqueStorage()._offloadScanBatchingSupport = newValue}
  }

  ///NEWLY ADDED:  device iOS version
  var iOsVersion: String {
    get {return _storage._iOsVersion}
    set {_uniqueStorage()._iOsVersion = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// start device request message
/// the module will try to start the device, power it up,
/// get all rights, configure it for qaul, and
/// send & receive advertising messages
struct Qaul_Sys_Ble_BleStartRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var qaulID: Data = Data()

  var mode: Qaul_Sys_Ble_BleMode = .lowPower

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///To stop service, advertisement & scanning.
struct Qaul_Sys_Ble_BleStopRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// stop service feedback
/// this is the feedback
struct Qaul_Sys_Ble_BleStopResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// whether the stop of the device was a success or not
  var success: Bool = false

  /// error message
  var errorMessage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// start device result message
/// this is the feedback
struct Qaul_Sys_Ble_BleStartResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// whether the start of the device was a success or not
  var success: Bool = false

  /// error message
  var errorMessage: String = String()

  /// error reasons
  var unknownError: Bool = false

  /// rights not provided
  var noRights: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// advertising set message content
struct Qaul_Sys_Ble_BleAdvertisingSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// set data which can be used for interval data advertisement
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// send advertsing message
struct Qaul_Sys_Ble_BleAdvertisingSend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// advertising mode
  var mode: Qaul_Sys_Ble_BleMode = .lowPower

  /// the data to be sent in the data field
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Scan device received
struct Qaul_Sys_Ble_BleScanResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the Bluetooth address of the device sending the advertisement
  var mac: String = String()

  /// the received signal strength of this device
  var rssi: Int32 = 0

  /// time when device found/out of range
  var timestamp: String = String()

  /// the data part of the advertising message
  var isConnectable: Bool = false

  /// name of the device
  var name: String = String()

  /// is device in the range
  var isInTheRange: Bool = false

  /// qaul_id
  var qaulID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// send a direct message
struct Qaul_Sys_Ble_BleDirectSend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message id (as a reference for the result message)
  var id: String = String()

  /// qaul_id of the device to send it to
  var to: Data = Data()

  /// data to be sent
  var data: Data = Data()

  /// qaul_id_sender
  var qaulID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// result after sending the direct message
struct Qaul_Sys_Ble_BleDirectSendResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message id
  var id: String = String()

  /// result after sending the message
  var success: Bool = false

  /// error messages
  var errorMessage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// direct message received message
struct Qaul_Sys_Ble_BleDirectReceived {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// bluetooth address of the sending device
  var from: String = String()

  /// qaul_id of the sending device
  var qaulID: Data = Data()

  /// the mode this message was sent in
  var mode: Qaul_Sys_Ble_BleMode = .lowPower

  /// the data received
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "qaul.sys.ble"

extension Qaul_Sys_Ble_BleMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "low_power"),
    1: .same(proto: "balanced"),
    2: .same(proto: "low_latency"),
  ]
}

extension Qaul_Sys_Ble_Ble: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ble"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "info_request"),
    2: .standard(proto: "info_response"),
    3: .standard(proto: "start_request"),
    4: .standard(proto: "start_result"),
    5: .standard(proto: "advertising_set"),
    6: .standard(proto: "advertising_send"),
    7: .standard(proto: "scan_result"),
    8: .standard(proto: "direct_send"),
    9: .standard(proto: "direct_send_result"),
    10: .standard(proto: "direct_received"),
    11: .standard(proto: "stop_request"),
    12: .standard(proto: "stop_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qaul_Sys_Ble_BleInfoRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .infoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .infoRequest(v)
        }
      }()
      case 2: try {
        var v: Qaul_Sys_Ble_BleInfoResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .infoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .infoResponse(v)
        }
      }()
      case 3: try {
        var v: Qaul_Sys_Ble_BleStartRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .startRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .startRequest(v)
        }
      }()
      case 4: try {
        var v: Qaul_Sys_Ble_BleStartResult?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .startResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .startResult(v)
        }
      }()
      case 5: try {
        var v: Qaul_Sys_Ble_BleAdvertisingSet?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .advertisingSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .advertisingSet(v)
        }
      }()
      case 6: try {
        var v: Qaul_Sys_Ble_BleAdvertisingSend?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .advertisingSend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .advertisingSend(v)
        }
      }()
      case 7: try {
        var v: Qaul_Sys_Ble_BleScanResult?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .scanResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .scanResult(v)
        }
      }()
      case 8: try {
        var v: Qaul_Sys_Ble_BleDirectSend?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .directSend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .directSend(v)
        }
      }()
      case 9: try {
        var v: Qaul_Sys_Ble_BleDirectSendResult?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .directSendResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .directSendResult(v)
        }
      }()
      case 10: try {
        var v: Qaul_Sys_Ble_BleDirectReceived?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .directReceived(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .directReceived(v)
        }
      }()
      case 11: try {
        var v: Qaul_Sys_Ble_BleStopRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .stopRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .stopRequest(v)
        }
      }()
      case 12: try {
        var v: Qaul_Sys_Ble_BleStopResult?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .stopResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .stopResult(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .infoRequest?: try {
      guard case .infoRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .infoResponse?: try {
      guard case .infoResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .startRequest?: try {
      guard case .startRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .startResult?: try {
      guard case .startResult(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .advertisingSet?: try {
      guard case .advertisingSet(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .advertisingSend?: try {
      guard case .advertisingSend(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .scanResult?: try {
      guard case .scanResult(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .directSend?: try {
      guard case .directSend(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .directSendResult?: try {
      guard case .directSendResult(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .directReceived?: try {
      guard case .directReceived(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .stopRequest?: try {
      guard case .stopRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .stopResult?: try {
      guard case .stopResult(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_Ble, rhs: Qaul_Sys_Ble_Ble) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleInfoRequest, rhs: Qaul_Sys_Ble_BleInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleInfoResponse, rhs: Qaul_Sys_Ble_BleInfoResponse) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleDeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleDeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "location_permission"),
    2: .standard(proto: "location_on"),
    3: .standard(proto: "ble_permission"),
    4: .standard(proto: "bluetooth_on"),
    5: .standard(proto: "android_version"),
    6: .same(proto: "name"),
    7: .standard(proto: "ble_support"),
    8: .standard(proto: "adv_251"),
    9: .standard(proto: "adv_extended_bytes"),
    10: .standard(proto: "adv_1m"),
    11: .standard(proto: "adv_2m"),
    12: .standard(proto: "adv_coded"),
    13: .standard(proto: "le_audio"),
    14: .standard(proto: "le_periodic_adv_support"),
    15: .standard(proto: "le_multiple_adv_support"),
    16: .standard(proto: "offload_filter_support"),
    17: .standard(proto: "offload_scan_batching_support"),
    18: .standard(proto: "iOS_version"),
  ]

  fileprivate class _StorageClass {
    var _locationPermission: Bool = false
    var _locationOn: Bool = false
    var _blePermission: Bool = false
    var _bluetoothOn: Bool = false
    var _androidVersion: Int32 = 0
    var _name: String = String()
    var _bleSupport: Bool = false
    var _adv251: Bool = false
    var _advExtendedBytes: UInt32 = 0
    var _adv1M: Bool = false
    var _adv2M: Bool = false
    var _advCoded: Bool = false
    var _leAudio: Bool = false
    var _lePeriodicAdvSupport: Bool = false
    var _leMultipleAdvSupport: Bool = false
    var _offloadFilterSupport: Bool = false
    var _offloadScanBatchingSupport: Bool = false
    var _iOsVersion: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _locationPermission = source._locationPermission
      _locationOn = source._locationOn
      _blePermission = source._blePermission
      _bluetoothOn = source._bluetoothOn
      _androidVersion = source._androidVersion
      _name = source._name
      _bleSupport = source._bleSupport
      _adv251 = source._adv251
      _advExtendedBytes = source._advExtendedBytes
      _adv1M = source._adv1M
      _adv2M = source._adv2M
      _advCoded = source._advCoded
      _leAudio = source._leAudio
      _lePeriodicAdvSupport = source._lePeriodicAdvSupport
      _leMultipleAdvSupport = source._leMultipleAdvSupport
      _offloadFilterSupport = source._offloadFilterSupport
      _offloadScanBatchingSupport = source._offloadScanBatchingSupport
      _iOsVersion = source._iOsVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._locationPermission) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._locationOn) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._blePermission) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._bluetoothOn) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._androidVersion) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._bleSupport) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._adv251) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._advExtendedBytes) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._adv1M) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._adv2M) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._advCoded) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._leAudio) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._lePeriodicAdvSupport) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._leMultipleAdvSupport) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._offloadFilterSupport) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._offloadScanBatchingSupport) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._iOsVersion) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._locationPermission != false {
        try visitor.visitSingularBoolField(value: _storage._locationPermission, fieldNumber: 1)
      }
      if _storage._locationOn != false {
        try visitor.visitSingularBoolField(value: _storage._locationOn, fieldNumber: 2)
      }
      if _storage._blePermission != false {
        try visitor.visitSingularBoolField(value: _storage._blePermission, fieldNumber: 3)
      }
      if _storage._bluetoothOn != false {
        try visitor.visitSingularBoolField(value: _storage._bluetoothOn, fieldNumber: 4)
      }
      if _storage._androidVersion != 0 {
        try visitor.visitSingularInt32Field(value: _storage._androidVersion, fieldNumber: 5)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 6)
      }
      if _storage._bleSupport != false {
        try visitor.visitSingularBoolField(value: _storage._bleSupport, fieldNumber: 7)
      }
      if _storage._adv251 != false {
        try visitor.visitSingularBoolField(value: _storage._adv251, fieldNumber: 8)
      }
      if _storage._advExtendedBytes != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._advExtendedBytes, fieldNumber: 9)
      }
      if _storage._adv1M != false {
        try visitor.visitSingularBoolField(value: _storage._adv1M, fieldNumber: 10)
      }
      if _storage._adv2M != false {
        try visitor.visitSingularBoolField(value: _storage._adv2M, fieldNumber: 11)
      }
      if _storage._advCoded != false {
        try visitor.visitSingularBoolField(value: _storage._advCoded, fieldNumber: 12)
      }
      if _storage._leAudio != false {
        try visitor.visitSingularBoolField(value: _storage._leAudio, fieldNumber: 13)
      }
      if _storage._lePeriodicAdvSupport != false {
        try visitor.visitSingularBoolField(value: _storage._lePeriodicAdvSupport, fieldNumber: 14)
      }
      if _storage._leMultipleAdvSupport != false {
        try visitor.visitSingularBoolField(value: _storage._leMultipleAdvSupport, fieldNumber: 15)
      }
      if _storage._offloadFilterSupport != false {
        try visitor.visitSingularBoolField(value: _storage._offloadFilterSupport, fieldNumber: 16)
      }
      if _storage._offloadScanBatchingSupport != false {
        try visitor.visitSingularBoolField(value: _storage._offloadScanBatchingSupport, fieldNumber: 17)
      }
      if !_storage._iOsVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._iOsVersion, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleDeviceInfo, rhs: Qaul_Sys_Ble_BleDeviceInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._locationPermission != rhs_storage._locationPermission {return false}
        if _storage._locationOn != rhs_storage._locationOn {return false}
        if _storage._blePermission != rhs_storage._blePermission {return false}
        if _storage._bluetoothOn != rhs_storage._bluetoothOn {return false}
        if _storage._androidVersion != rhs_storage._androidVersion {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._bleSupport != rhs_storage._bleSupport {return false}
        if _storage._adv251 != rhs_storage._adv251 {return false}
        if _storage._advExtendedBytes != rhs_storage._advExtendedBytes {return false}
        if _storage._adv1M != rhs_storage._adv1M {return false}
        if _storage._adv2M != rhs_storage._adv2M {return false}
        if _storage._advCoded != rhs_storage._advCoded {return false}
        if _storage._leAudio != rhs_storage._leAudio {return false}
        if _storage._lePeriodicAdvSupport != rhs_storage._lePeriodicAdvSupport {return false}
        if _storage._leMultipleAdvSupport != rhs_storage._leMultipleAdvSupport {return false}
        if _storage._offloadFilterSupport != rhs_storage._offloadFilterSupport {return false}
        if _storage._offloadScanBatchingSupport != rhs_storage._offloadScanBatchingSupport {return false}
        if _storage._iOsVersion != rhs_storage._iOsVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleStartRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleStartRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "qaul_id"),
    2: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.qaulID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.qaulID.isEmpty {
      try visitor.visitSingularBytesField(value: self.qaulID, fieldNumber: 1)
    }
    if self.mode != .lowPower {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleStartRequest, rhs: Qaul_Sys_Ble_BleStartRequest) -> Bool {
    if lhs.qaulID != rhs.qaulID {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleStopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleStopRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleStopRequest, rhs: Qaul_Sys_Ble_BleStopRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleStopResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleStopResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "error_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleStopResult, rhs: Qaul_Sys_Ble_BleStopResult) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleStartResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleStartResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "error_message"),
    3: .standard(proto: "unknown_error"),
    4: .standard(proto: "no_rights"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.unknownError) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.noRights) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    if self.unknownError != false {
      try visitor.visitSingularBoolField(value: self.unknownError, fieldNumber: 3)
    }
    if self.noRights != false {
      try visitor.visitSingularBoolField(value: self.noRights, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleStartResult, rhs: Qaul_Sys_Ble_BleStartResult) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownError != rhs.unknownError {return false}
    if lhs.noRights != rhs.noRights {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleAdvertisingSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleAdvertisingSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleAdvertisingSet, rhs: Qaul_Sys_Ble_BleAdvertisingSet) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleAdvertisingSend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleAdvertisingSend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .lowPower {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleAdvertisingSend, rhs: Qaul_Sys_Ble_BleAdvertisingSend) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleScanResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleScanResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mac"),
    2: .same(proto: "rssi"),
    3: .same(proto: "timestamp"),
    4: .standard(proto: "is_connectable"),
    5: .same(proto: "name"),
    6: .standard(proto: "is_in_the_range"),
    7: .standard(proto: "qaul_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mac) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.rssi) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isConnectable) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isInTheRange) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.qaulID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mac.isEmpty {
      try visitor.visitSingularStringField(value: self.mac, fieldNumber: 1)
    }
    if self.rssi != 0 {
      try visitor.visitSingularInt32Field(value: self.rssi, fieldNumber: 2)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 3)
    }
    if self.isConnectable != false {
      try visitor.visitSingularBoolField(value: self.isConnectable, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if self.isInTheRange != false {
      try visitor.visitSingularBoolField(value: self.isInTheRange, fieldNumber: 6)
    }
    if !self.qaulID.isEmpty {
      try visitor.visitSingularBytesField(value: self.qaulID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleScanResult, rhs: Qaul_Sys_Ble_BleScanResult) -> Bool {
    if lhs.mac != rhs.mac {return false}
    if lhs.rssi != rhs.rssi {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.isConnectable != rhs.isConnectable {return false}
    if lhs.name != rhs.name {return false}
    if lhs.isInTheRange != rhs.isInTheRange {return false}
    if lhs.qaulID != rhs.qaulID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleDirectSend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleDirectSend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "to"),
    3: .same(proto: "data"),
    4: .standard(proto: "qaul_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.to) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.qaulID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularBytesField(value: self.to, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    if !self.qaulID.isEmpty {
      try visitor.visitSingularBytesField(value: self.qaulID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleDirectSend, rhs: Qaul_Sys_Ble_BleDirectSend) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.to != rhs.to {return false}
    if lhs.data != rhs.data {return false}
    if lhs.qaulID != rhs.qaulID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleDirectSendResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleDirectSendResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "success"),
    3: .standard(proto: "error_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleDirectSendResult, rhs: Qaul_Sys_Ble_BleDirectSendResult) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qaul_Sys_Ble_BleDirectReceived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BleDirectReceived"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .standard(proto: "qaul_id"),
    3: .same(proto: "mode"),
    4: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.from) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.qaulID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 1)
    }
    if !self.qaulID.isEmpty {
      try visitor.visitSingularBytesField(value: self.qaulID, fieldNumber: 2)
    }
    if self.mode != .lowPower {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Qaul_Sys_Ble_BleDirectReceived, rhs: Qaul_Sys_Ble_BleDirectReceived) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.qaulID != rhs.qaulID {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
